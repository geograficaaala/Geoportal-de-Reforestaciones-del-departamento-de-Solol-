<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Incendios — Dashboard FIRMS (NRT) · Sololá</title>
  <meta name="description" content="Dashboard SIG de anomalías térmicas (FIRMS NRT): filtros por periodo, sensores y recortes espaciales con KPIs geoestadísticos." />

  <!-- Leaflet (sin SRI para evitar bloqueos) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin=""></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- SheetJS (Excel export) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    :root{
      --bg-0:#fff7f0;
      --bg-1:#fff2e6;
      --card:rgba(255,255,255,.92);
      --card2:rgba(255,255,255,.98);
      --ink:#2b1d12;
      --muted:#6a4e3c;
      --brand:#ff7a45;
      --stroke:rgba(32,18,10,.12);

      --hi:#ff5a5f;
      --nom:#ffb703;
      --low:#6c757d;

      --shadow: 0 14px 40px rgba(40,20,10,.12);
      --shadow-sm: 0 10px 22px rgba(40,20,10,.10);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      color:var(--ink);
      background:
        radial-gradient(900px 560px at 0% 0%, rgba(255,122,69,.18), transparent 62%),
        radial-gradient(900px 560px at 100% 0%, rgba(255,183,3,.16), transparent 62%),
        linear-gradient(180deg, var(--bg-0), var(--bg-1));
      min-height:100vh;
    }

    header{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: rgba(255,255,255,.78);
      border-bottom: 1px solid var(--stroke);
    }
    .header-wrap{
      padding: 10px 14px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{ display:flex; flex-direction:column; gap:2px; min-width: 260px; }
    .title h1{ margin:0; font-size: 15px; letter-spacing:.2px; }
    .title .sub{ font-size:12px; color:var(--muted); }

    .chips{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 999px;
      box-shadow: var(--shadow-sm);
      font-size:12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: #2fd08f;
      box-shadow: 0 0 0 4px rgba(47,208,143,.18);
    }

    main{
      display:grid;
      grid-template-columns: 390px 1fr;
      gap:14px;
      padding: 14px 14px 18px;
      align-items:stretch;
    }
    .panel{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-width:0;
    }
    .panel h2{
      margin:0;
      padding:12px 14px;
      font-size:13px;
      color:#3a2416;
      border-bottom: 1px solid rgba(0,0,0,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.82));
    }
    .panel .content{ padding: 12px 14px 14px; }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    select, input[type="text"], input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      outline:none;
    }
    input[type="checkbox"]{ transform: translateY(1px); }

    .checks{
      display:grid; gap:8px;
      padding:10px;
      background:#fff;
      border:1px solid rgba(0,0,0,.14);
      border-radius:12px;
    }
    .checks .row{ display:flex; gap:8px; align-items:flex-start; font-size:12.5px; color:#3a2416; }
    .checks small{ display:block; color:var(--muted); margin-top:2px; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      border:none; cursor:pointer;
      padding:10px 12px;
      border-radius: 12px;
      font-weight:800; font-size:12.5px;
    }
    .btn-primary{ background: linear-gradient(135deg, var(--brand), #ffb45a); color:#fff; }
    .btn-ghost{ background:#fff; border:1px solid rgba(0,0,0,.14); color:#2b1d12; }

    .status{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:#fff;
      border:1px dashed rgba(255,122,69,.35);
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }

    .notes{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
      border:1px solid rgba(0,0,0,.10);
      color: var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .notes ul{ margin:8px 0 0; padding-left: 18px; }
    .notes li{ margin:6px 0; }

    .right{
      display:grid;
      grid-template-rows: auto auto auto 1fr;
      gap:14px;
      min-width:0;
    }

    .mapWrap{ padding:12px 14px 14px; position:relative; }
    #map{
      height: 520px;
      min-height: 520px;
      border-radius: var(--radius);
      background: #f6efe9;
      outline: 1px solid rgba(0,0,0,.06);
    }
    .mapError{
      display:none;
      position:absolute;
      inset: 16px 18px auto 18px;
      background: rgba(255,255,255,.96);
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: var(--shadow-sm);
      color: #7b3b1f;
      font-size: 12px;
      line-height: 1.35;
    }
    .mapError code{ background:#f3f3f3; padding:2px 6px; border-radius:8px; }

    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      padding: 0 14px 14px;
      font-size:12px; color:var(--muted);
    }
    .lg{
      display:flex; align-items:center; gap:6px;
      padding:6px 8px;
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:999px;
    }
    .sw{ width:10px; height:10px; border-radius:50%; }

    .kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
      padding: 12px 14px 14px;
    }
    .kpi{
      border:1px solid rgba(0,0,0,.10);
      border-radius: 14px;
      padding:10px;
      background:#fff;
      min-width:0;
    }
    .kpi .k{ font-size:11px; color:var(--muted); }
    .kpi .v{ font-size:16px; font-weight:950; margin-top:4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    .geoKpiGrid{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
      padding: 12px 14px 14px;
    }
    .geoKpi{
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:14px;
      padding:10px;
      min-width:0;
    }
    .geoKpi .k{ font-size:11px; color:var(--muted); }
    .geoKpi .v{ font-size:15px; font-weight:950; margin-top:4px; }
    .geoKpi .s{ font-size:11px; color:var(--muted); margin-top:4px; line-height:1.25; }

    .analysisGrid{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:14px;
      min-width:0;
      padding-bottom: 14px;
    }
    .filters{ display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    .filters input{ flex:1; min-width: 220px; }

    .tableWrap{
      overflow:auto;
      max-height: 420px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.10);
      background:#fff;
    }
    table{ width:100%; border-collapse: collapse; font-size:12px; }
    thead th{
      position:sticky; top:0; z-index:1;
      background:#fff3e6;
      border-bottom:1px solid rgba(0,0,0,.10);
      text-align:left;
      padding:10px 8px;
      color:#3a2416;
      white-space:nowrap;
    }
    tbody td{
      border-bottom:1px solid rgba(0,0,0,.06);
      padding:8px 8px;
      color:#2b1d12;
      vertical-align:top;
      white-space:nowrap;
    }
    tbody tr:hover{ background:#fff7f0; cursor:pointer; }

    .hint{ font-size:12px; color:var(--muted); line-height:1.35; margin-top:8px; }

    .hotspot{
      width:14px; height:14px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,.92);
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
    }

    footer{
      padding: 10px 14px 24px;
      color: var(--muted);
      font-size: 12px;
    }
    .footer-box{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px 14px;
    }
    .footer-logos{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      align-items:center;
      justify-content:center;
      margin-top:10px;
    }
    .footer-logos img{
      max-height: 44px;
      width: auto;
      object-fit: contain;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.06));
      background: rgba(255,255,255,.94);
      border-radius: 10px;
      padding: 4px 6px;
    }

    @media (max-width: 1100px){
      main{ grid-template-columns: 1fr; }
      .kpis{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .geoKpiGrid{ grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .analysisGrid{ grid-template-columns: 1fr; }
      #map{ height: 440px; min-height: 440px; }
    }
  </style>
</head>

<body>
  <header>
    <div class="header-wrap">
      <div class="title">
        <h1>Incendios forestales — Anomalías térmicas (FIRMS NRT)</h1>
        <div class="sub">Sololá · Recortes SIG (BBOX / Municipios / Microcuencas / Áreas protegidas) · UTC</div>
      </div>

      <div class="chips">
        <div class="chip" title="Estado del proxy">
          <span class="dot" id="dot"></span>
          <span id="pillText">Proxy: sin verificar</span>
        </div>
        <div class="chip" title="Auto actualización">
          <input id="auto" type="checkbox" checked />
          <label for="auto" style="margin:0; cursor:pointer;">Auto (10 min)</label>
        </div>
        <div class="chip" id="lastRun">Última actualización: —</div>
      </div>
    </div>
  </header>

  <main>
    <!-- Left controls -->
    <section class="panel">
      <h2>Filtros</h2>
      <div class="content">
        <div class="grid2">
          <div>
            <label for="days">Período</label>
            <select id="days">
              <option value="1">24 horas (1 día)</option>
              <option value="3" selected>72 horas (3 días)</option>
              <option value="7">7 días</option>
              <option value="30">30 días</option>
              <option value="60">60 días</option>
              <option value="90">90 días</option>
            </select>
          </div>
          <div>
            <label for="clipMode">Recorte espacial</label>
            <select id="clipMode">
              <option value="bbox_solola" selected>Sololá (BBOX)</option>
              <option value="bbox_guatemala">Guatemala (BBOX)</option>
              <option value="bbox_map">Extensión del mapa (BBOX)</option>
              <option value="bbox_manual">BBOX personalizado</option>
              <option value="muni">Municipio (Sololá)</option>
              <option value="micro">Microcuenca (Atitlán)</option>
              <option value="ap">Área protegida</option>
            </select>
          </div>
        </div>

        <div id="manualBBox" style="display:none; margin-top:10px">
          <label>BBOX manual (west,south,east,north)</label>
          <div class="grid2">
            <input type="number" step="0.000001" id="w" placeholder="west (lon)">
            <input type="number" step="0.000001" id="e" placeholder="east (lon)">
          </div>
          <div style="height:8px"></div>
          <div class="grid2">
            <input type="number" step="0.000001" id="s" placeholder="south (lat)">
            <input type="number" step="0.000001" id="n" placeholder="north (lat)">
          </div>
        </div>

        <div id="polyPick" style="display:none; margin-top:10px">
          <label id="polyLabel">Selección</label>
          <select id="polySelect"></select>
          <div class="hint" id="polyHint"></div>
        </div>

        <div style="height:10px"></div>

        <label>Sensores (Near Real-Time)</label>
        <div class="checks">
          <div class="row">
            <input type="checkbox" id="s_snpp" checked>
            <div><b>VIIRS Suomi-NPP</b><small>VIIRS_SNPP_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_n20" checked>
            <div><b>VIIRS NOAA-20 (JPSS-1)</b><small>VIIRS_NOAA20_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_n21" checked>
            <div><b>VIIRS NOAA-21 (JPSS-2)</b><small>VIIRS_NOAA21_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_modis" checked>
            <div><b>MODIS (Terra/Aqua) NRT</b><small>MODIS_NRT</small></div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="grid2">
          <div>
            <label for="conf">Confianza del algoritmo</label>
            <select id="conf">
              <option value="all" selected>Todas</option>
              <option value="high">Alta</option>
              <option value="nominal">Nominal/Media</option>
              <option value="low">Baja</option>
            </select>
          </div>
          <div>
            <label for="limit">Límite filas</label>
            <select id="limit">
              <option value="2000">2,000</option>
              <option value="10000" selected>10,000</option>
              <option value="20000">20,000</option>
              <option value="50000">50,000</option>
            </select>
          </div>
        </div>

        <div class="btns">
          <button class="btn-primary" id="btnRun">Actualizar</button>
          <button class="btn-ghost" id="btnFit">Ajustar mapa</button>
          <button class="btn-ghost" id="btnCSV">CSV</button>
          <button class="btn-ghost" id="btnExcel">Excel</button>
          <button class="btn-ghost" id="btnGeoJSON">GeoJSON</button>
        </div>

        <div class="status" id="status">Listo.</div>

        <div class="notes">
          <b>Notas técnicas (FIRMS Active Fire / NRT)</b>
          <ul>
            <li>Hotspots ≠ perímetro. VIIRS (Suomi‑NPP / NOAA‑20 / NOAA‑21) y MODIS (Terra/Aqua) detectan <b>fuego activo/anomalía térmica</b>.</li>
            <li>La observación depende del <b>paso orbital</b> y de nubosidad/humo; puede haber omisiones y múltiples detecciones del mismo evento.</li>
            <li>Resolución aproximada: <b>VIIRS ~375 m</b> y <b>MODIS ~1 km</b>. La ubicación es una aproximación del píxel detectado.</li>
            <li>FRP (MW) es un indicador radiativo de energía del fuego (no es área quemada).</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Right -->
    <section class="right">
      <section class="panel">
        <h2>Mapa</h2>
        <div class="mapWrap">
          <div id="map"></div>
          <div class="mapError" id="mapError"></div>
        </div>
        <div class="legend">
          <div class="lg"><span class="sw" style="background:var(--hi)"></span> Alta</div>
          <div class="lg"><span class="sw" style="background:var(--nom)"></span> Nominal/Media</div>
          <div class="lg"><span class="sw" style="background:var(--low)"></span> Baja</div>
        </div>
      </section>

      <section class="panel">
        <h2>KPIs</h2>
        <div class="kpis">
          <div class="kpi"><div class="k">Detecciones (filtradas)</div><div class="v" id="k_total">—</div></div>
          <div class="kpi"><div class="k">Alta confianza</div><div class="v" id="k_high">—</div></div>
          <div class="kpi"><div class="k">FRP total (MW)</div><div class="v" id="k_frp">—</div></div>
          <div class="kpi"><div class="k">Última detección (UTC)</div><div class="v" id="k_last">—</div></div>
        </div>
      </section>

      <section class="panel">
        <h2>Geoestadística</h2>
        <div class="geoKpiGrid">
          <div class="geoKpi"><div class="k">Área A (km²)</div><div class="v" id="g_area">—</div><div class="s" id="g_area_s">recorte actual</div></div>
          <div class="geoKpi"><div class="k">n (muestra / total)</div><div class="v" id="g_n">—</div><div class="s" id="g_n_s">cap O(n²)</div></div>
          <div class="geoKpi"><div class="k">Intensidad λ (pts/km²)</div><div class="v" id="g_lambda">—</div><div class="s">λ = n/A</div></div>
          <div class="geoKpi"><div class="k">NNI (Clark–Evans)</div><div class="v" id="g_nni">—</div><div class="s" id="g_nni_s">r̄obs / r̄exp</div></div>

          <div class="geoKpi"><div class="k">z-score (NNI)</div><div class="v" id="g_z">—</div><div class="s" id="g_p">p: —</div></div>
          <div class="geoKpi"><div class="k">Ripley L(r) pico</div><div class="v" id="g_lmax">—</div><div class="s" id="g_lr">escala r: — km</div></div>
          <div class="geoKpi"><div class="k">CSR Monte Carlo</div><div class="v" id="g_mc">—</div><div class="s" id="g_mc_s">p(cluster): —</div></div>
          <div class="geoKpi"><div class="k">SDE (σ, km)</div><div class="v" id="g_sd">—</div><div class="s" id="g_sde">elipse: —</div></div>
        </div>
        <div class="content">
          <div class="hint" id="g_note">
            Ecuaciones: r̄exp = 0.5/√λ (CSR) · K(r)=(A/(n(n−1)))·2·#{d≤r} · L(r)=√(K/π)−r · γ(h)=½·mean[(zᵢ−zⱼ)²]
          </div>
        </div>
      </section>

      <section class="panel">
        <h2>Análisis</h2>
        <div class="content">
          <div class="analysisGrid">
            <div>
              <div class="filters">
                <input id="q" type="text" placeholder="Filtrar tabla (zona, sensor, fecha, satélite…)" />
                <button class="btn-ghost" id="btnClear">Limpiar filtro</button>
              </div>

              <div class="tableWrap">
                <table id="tbl">
                  <thead>
                    <tr>
                      <th>UTC</th>
                      <th>Zona</th>
                      <th>Sensor</th>
                      <th>Conf.</th>
                      <th>Lat</th>
                      <th>Lon</th>
                      <th>FRP</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>

              <div class="hint" id="tableNote"></div>
            </div>

            <div>
              <canvas id="chartDaily" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartSensors" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartRipley" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartVariogram" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartNN" height="160"></canvas>
              <div class="hint" id="trendNote"></div>
            </div>
          </div>
        </div>
      </section>
    </section>
  </main>

  <footer>
    <div class="footer-box">
      <div style="text-align:center; font-weight:800;">Eje de Bosques · CODEMA Sololá · Instituciones participantes</div>
      <div class="footer-logos" aria-label="Logos institucionales">
        <img src="../../BOSQUE.png" alt="Eje de Bosques">
        <img src="../../CODEMA%20%282%29.png" alt="CODEMA Sololá">
        <img src="../../marn.png" alt="MARN">
        <img src="../../maga.png" alt="MAGA">
        <img src="../../inab.png" alt="INAB">
        <img src="../../conap.png" alt="CONAP">
        <img src="../../amsclae.png" alt="AMSCLAE">
        <img src="../../conred.png" alt="CONRED">
        <img src="../../cea.png" alt="CEA - UVG">
        <img src="../../aala_logo.png" alt="Amigos del Lago de Atitlán">
        <img src="../../vivamos.png" alt="Vivamos Mejor Guatemala">
        <img src="../../aires.png" alt="AIR">
      </div>
      <div style="text-align:center; margin-top:10px;">
        Fuentes: NASA FIRMS (LANCE) — Active Fire (NRT) · Geoprocesos (Turf.js) · Visualización (Leaflet/Chart.js)
      </div>
    </div>
  </footer>

<script>
(() => {
  const PROXY_BASE = "https://royal-dust-e52cfirms-proxy-solola.sgeograficaaala.workers.dev";
  const LAYER_SOURCES = {
    muni:  { url: "./data/municipios_solola.geojson", label: "Municipio (Sololá)" },
    micro: { url: "./data/microcuencas_atitlan.geojson", label: "Microcuenca (Atitlán)" },
    ap:    { url: "./data/areas_protegidas.geojson", label: "Área protegida" },
  };
  const BBOX_PRESETS = {
    solola:    [-91.586608, 14.495833, -91.040503, 14.992742],
    guatemala: [-92.3592, 13.5235, -88.0458, 18.0436],
  };

  const $ = (id) => document.getElementById(id);
  const mapError = $("mapError");

  function showMapError(msg){
    if (!mapError) return;
    mapError.style.display = "block";
    mapError.innerHTML = msg;
  }

  window.addEventListener("error", (e) => {
    const m = (e && e.message) ? e.message : "Error desconocido";
    showMapError(`Error JavaScript: <code>${m}</code><br/>Abre DevTools → Console para ver detalles.`);
  });

  function confClass(c){
    const s = String(c ?? "").trim().toLowerCase();
    const n = Number(s);
    if (!Number.isNaN(n)){
      if (n >= 80) return "high";
      if (n >= 30) return "nominal";
      return "low";
    }
    if (["h","high"].includes(s)) return "high";
    if (["n","nominal","m","medium"].includes(s)) return "nominal";
    if (["l","low"].includes(s)) return "low";
    return "unknown";
  }
  function confColor(c){
    const k = confClass(c);
    const css = getComputedStyle(document.documentElement);
    if (k === "high") return css.getPropertyValue("--hi").trim();
    if (k === "nominal") return css.getPropertyValue("--nom").trim();
    return css.getPropertyValue("--low").trim();
  }
  function fmt(n, d=0){
    if (n === null || n === undefined || Number.isNaN(n)) return "—";
    return new Intl.NumberFormat("es-GT",{ maximumFractionDigits:d }).format(n);
  }
  function bboxStr(arr){ return arr.map(v => Number(v.toFixed(6))).join(","); }
  function setStatus(msg){ $("status").textContent = msg; }

  function getSensors(){
    const out = [];
    if ($("s_snpp").checked) out.push("VIIRS_SNPP_NRT");
    if ($("s_n20").checked) out.push("VIIRS_NOAA20_NRT");
    if ($("s_n21").checked) out.push("VIIRS_NOAA21_NRT");
    if ($("s_modis").checked) out.push("MODIS_NRT");
    return out;
  }

  // MAP INIT
  if (!window.L){
    showMapError(`No se cargó Leaflet (<code>L</code>). Revisa tu conexión o si un bloqueador está deteniendo <code>unpkg.com</code>.`);
    return;
  }

  let map, clusters, overlayGroup;
  const iconCache = new Map();
  function markerIcon(color){
    if (iconCache.has(color)) return iconCache.get(color);
    const icon = L.divIcon({
      className: "",
      html: `<div class="hotspot" style="background:${color}"></div>`,
      iconSize: [14,14],
      iconAnchor: [7,7],
      popupAnchor: [0,-8]
    });
    iconCache.set(color, icon);
    return icon;
  }

  try{
    map = L.map("map", { zoomControl: true }).setView([14.77, -91.18], 10);

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors',
    }).addTo(map);

    const imagery = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      maxZoom: 19,
      attribution: "Tiles &copy; Esri",
    });

    L.control.layers({ "OSM": osm, "Satélite (Esri)": imagery }, {}, { position: "topleft" }).addTo(map);

    if (typeof L.markerClusterGroup === "function"){
      clusters = L.markerClusterGroup({ chunkedLoading: true, showCoverageOnHover: false, maxClusterRadius: 55 });
    } else {
      clusters = L.layerGroup();
      setStatus("Aviso: no se cargó Leaflet.markercluster; usando capa simple.");
    }
    map.addLayer(clusters);

    overlayGroup = L.layerGroup().addTo(map);
    setTimeout(() => map.invalidateSize(), 250);
  }catch(err){
    showMapError(`No se pudo inicializar el mapa: <code>${String(err)}</code>`);
    return;
  }

  // POLYGONS
  const polyState = {
    muni:  { loaded:false, gj:null, items:[], nameField:null },
    micro: { loaded:false, gj:null, items:[], nameField:null },
    ap:    { loaded:false, gj:null, items:[], nameField:null },
  };

  function pickNameField(gj){
    if (!gj?.features?.length) return null;
    const preferred = ["NOMBRE","Nombre","nombre","MUNICIPIO","municipio","NOM_MUNI","MICROCUENCA","microcuenca","NOM_AREA","NAME","name"];
    const props = gj.features.map(f => f.properties || {});
    for (const key of preferred){
      let hits = 0;
      for (const p of props){
        const v = p[key];
        if (typeof v === "string" && v.trim()) hits++;
      }
      if (hits >= Math.max(2, Math.floor(props.length * 0.2))) return key;
    }
    const first = props[0] || {};
    for (const [k,v] of Object.entries(first)){
      if (typeof v === "string" && v.trim()) return k;
    }
    return null;
  }

  async function ensurePolyLoaded(mode){
    const st = polyState[mode];
    if (!st || st.loaded) return;

    const src = LAYER_SOURCES[mode];
    const r = await fetch(src.url, { cache: "no-store" });
    if (!r.ok) throw new Error(`No se pudo cargar ${src.url} (HTTP ${r.status})`);
    const gj = await r.json();

    st.gj = gj;
    st.nameField = pickNameField(gj);

    const items = [];
    for (let i = 0; i < (gj.features || []).length; i++){
      const f = gj.features[i];
      const id = f.id ?? (f.properties?.id ?? i);
      const nm = st.nameField ? String(f.properties?.[st.nameField] ?? "").trim() : `Polígono ${i+1}`;
      const bb = turf.bbox(f);
      items.push({ id: String(id), name: nm || `Polígono ${i+1}`, feature: f, bbox: bb, area_m2: turf.area(f) });
    }
    items.sort((a,b) => a.name.localeCompare(b.name, "es"));
    st.items = items;
    st.loaded = true;
  }

  function renderPolyOverlay(mode, selectedId){
    overlayGroup.clearLayers();
    const st = polyState[mode];
    if (!st?.loaded) return;

    let features = [];
    if (selectedId === "all"){
      features = st.gj.features;
    } else {
      const it = st.items.find(x => x.id === selectedId);
      if (it) features = [it.feature];
    }
    if (!features.length) return;

    L.geoJSON({ type:"FeatureCollection", features }, {
      style: { color:"#ff7a45", weight:2, opacity:0.85, fillColor:"#ffb703", fillOpacity:0.08 }
    }).addTo(overlayGroup);
  }

  function populatePolySelect(mode){
    const st = polyState[mode];
    const src = LAYER_SOURCES[mode];

    $("polyLabel").textContent = `Selecciona ${src.label}`;
    $("polyHint").textContent = `Campo etiqueta: ${st.nameField || "auto"} · Polígonos: ${st.items.length}`;

    const sel = $("polySelect");
    sel.innerHTML = "";

    const optAll = document.createElement("option");
    optAll.value = "all";
    optAll.textContent = `Todos (${st.items.length})`;
    sel.appendChild(optAll);

    for (const it of st.items){
      const opt = document.createElement("option");
      opt.value = it.id;
      opt.textContent = it.name;
      sel.appendChild(opt);
    }
    sel.value = "all";
  }

  function getBBoxFromUI(){
    const clipMode = $("clipMode").value;

    if (clipMode === "bbox_solola") return BBOX_PRESETS.solola;
    if (clipMode === "bbox_guatemala") return BBOX_PRESETS.guatemala;

    if (clipMode === "bbox_map"){
      const b = map.getBounds();
      return [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()];
    }
    if (clipMode === "bbox_manual"){
      const w = Number($("w").value), s = Number($("s").value), e = Number($("e").value), n = Number($("n").value);
      if (![w,s,e,n].every(Number.isFinite) || e <= w || n <= s) return null;
      return [w,s,e,n];
    }
    if (["muni","micro","ap"].includes(clipMode)){
      const st = polyState[clipMode];
      if (!st?.loaded) return BBOX_PRESETS.solola;
      const selectedId = $("polySelect").value || "all";
      if (selectedId === "all") return turf.bbox(st.gj);
      const it = st.items.find(x => x.id === selectedId);
      return it ? it.bbox : turf.bbox(st.gj);
    }
    return BBOX_PRESETS.solola;
  }

  function fitToBBox(arr){
    const b = L.latLngBounds([arr[1], arr[0]], [arr[3], arr[2]]);
    map.fitBounds(b.pad(0.06));
  }

  function getStudyPolygonForCSR(){
    const clipMode = $("clipMode").value;

    if (!["muni","micro","ap"].includes(clipMode)){
      const bb = getBBoxFromUI();
      const poly = turf.bboxPolygon(bb);
      return { poly, bbox: bb, areaKm2: turf.area(poly)/1e6, label: "BBOX" };
    }

    const st = polyState[clipMode];
    if (!st?.loaded){
      const bb = BBOX_PRESETS.solola;
      const poly = turf.bboxPolygon(bb);
      return { poly, bbox: bb, areaKm2: turf.area(poly)/1e6, label: "BBOX" };
    }

    const selectedId = $("polySelect").value || "all";
    if (selectedId !== "all"){
      const it = st.items.find(x => x.id === selectedId);
      if (it){
        return { poly: it.feature, bbox: it.bbox, areaKm2: it.area_m2/1e6, label: it.name };
      }
    }

    const bb = turf.bbox(st.gj);
    const poly = turf.bboxPolygon(bb);
    return { poly, bbox: bb, areaKm2: turf.area(poly)/1e6, label: `${LAYER_SOURCES[clipMode].label} (bbox)` };
  }

  function pointFilterByPolygon(rows){
    const clipMode = $("clipMode").value;
    if (!["muni","micro","ap"].includes(clipMode)) {
      return rows.map(r => ({...r, zone_type: "BBOX", zone_name: "—"}));
    }
    const st = polyState[clipMode];
    if (!st?.loaded){
      return rows.map(r => ({...r, zone_type: "SIG", zone_name: "—"}));
    }

    const selectedId = $("polySelect").value || "all";
    const polys = (selectedId === "all") ? st.items : st.items.filter(x => x.id === selectedId);
    const zoneType = LAYER_SOURCES[clipMode].label;

    const out = [];
    for (const r of rows){
      if (!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) continue;
      const pt = turf.point([r.lon, r.lat]);

      let matched = null;
      for (const it of polys){
        if (r.lon < it.bbox[0] || r.lon > it.bbox[2] || r.lat < it.bbox[1] || r.lat > it.bbox[3]) continue;
        if (turf.booleanPointInPolygon(pt, it.feature)){
          matched = it;
          break;
        }
      }
      if (matched) out.push({ ...r, zone_type: zoneType, zone_name: matched.name });
    }
    return out;
  }

  // TABLE + MAP
  let lastData = [];
  let markerById = new Map();

  let chartDaily = null;
  let chartSensors = null;
  let chartRipley = null;
  let chartVariogram = null;
  let chartNN = null;

  function updateMap(rows){
    clusters.clearLayers();
    markerById.clear();
    if (!rows?.length) return;

    for (const r of rows){
      const col = confColor(r.confidence);
      const mk = L.marker([r.lat, r.lon], { icon: markerIcon(col) });

      const zone = r.zone_name && r.zone_name !== "—" ? `<div><b>${r.zone_type}:</b> ${r.zone_name}</div>` : "";
      mk.bindPopup(`
        <div style="font-family:system-ui; font-size:12px; line-height:1.35">
          <div><b>${r.source}</b></div>
          ${zone}
          <div>UTC: ${r.datetime_utc || (r.acq_date + " " + r.acq_time)}</div>
          <div>Conf: ${r.confidence || "—"} · FRP: ${r.frp ?? "—"} MW</div>
          <div>Sat: ${r.satellite || "—"} · Inst: ${r.instrument || "—"}</div>
        </div>
      `);

      markerById.set(r.id, mk);
      clusters.addLayer(mk);
    }
  }

  function buildTable(rows){
    const tbody = $("tbl").querySelector("tbody");
    tbody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows){
      const tr = document.createElement("tr");
      tr.dataset.id = r.id;
      tr.innerHTML = `
        <td>${r.datetime_utc || "—"}</td>
        <td>${r.zone_name || "—"}</td>
        <td>${r.source || "—"}</td>
        <td>${r.confidence || "—"}</td>
        <td>${Number.isFinite(r.lat) ? r.lat.toFixed(5) : "—"}</td>
        <td>${Number.isFinite(r.lon) ? r.lon.toFixed(5) : "—"}</td>
        <td>${r.frp ?? "—"}</td>
      `;
      frag.appendChild(tr);
    }
    tbody.appendChild(frag);

    tbody.querySelectorAll("tr").forEach(tr => {
      tr.addEventListener("click", () => {
        const mk = markerById.get(tr.dataset.id);
        if (!mk) return;
        map.setView(mk.getLatLng(), Math.max(map.getZoom(), 13));
        mk.openPopup();
      });
    });
  }

  function applyFilter(){
    const q = $("q").value.trim().toLowerCase();
    const rows = $("tbl").querySelectorAll("tbody tr");
    let shown = 0;
    rows.forEach(tr => {
      const ok = !q || tr.textContent.toLowerCase().includes(q);
      tr.style.display = ok ? "" : "none";
      if (ok) shown++;
    });
    $("tableNote").textContent = `Mostrando ${shown} / ${lastData.length} filas (filtro local).`;
  }

  function updateKPIs(rawPayload, rows){
    const total = rows.length;
    const hi = rows.reduce((acc, r) => acc + (confClass(r.confidence) === "high" ? 1 : 0), 0);
    const frpSum = rows.reduce((acc, r) => acc + (Number.isFinite(r.frp) ? r.frp : 0), 0);

    $("k_total").textContent = fmt(total);
    $("k_high").textContent = fmt(hi);
    $("k_frp").textContent = fmt(frpSum, 3);
    $("k_last").textContent = rawPayload?.summary?.last_detection_utc || "—";
  }

  // EXPORTS
  function exportCSV(){
    if (!lastData.length) return;
    const cols = ["datetime_utc","zone_type","zone_name","source","confidence","lat","lon","frp","satellite","instrument","acq_date","acq_time"];
    const lines = [cols.join(",")];
    for (const r of lastData){
      const row = cols.map(c => {
        const v = (r[c] ?? "").toString();
        if (v.includes(",") || v.includes('"') || v.includes("\n")) return `"${v.replaceAll('"','""')}"`;
        return v;
      });
      lines.push(row.join(","));
    }
    const blob = new Blob([lines.join("\n")], { type:"text/csv;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "firs_hotspots_filtrados.csv";
    document.body.appendChild(a);
    a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }

  function exportExcel(){
    if (!lastData.length) return;
    if (!window.XLSX){
      setStatus("No se cargó XLSX (SheetJS). Usa CSV por ahora.");
      return;
    }
    const rows = lastData.map(r => ({
      datetime_utc: r.datetime_utc || "",
      zone_type: r.zone_type || "",
      zone_name: r.zone_name || "",
      source: r.source || "",
      confidence: r.confidence || "",
      lat: r.lat,
      lon: r.lon,
      frp: r.frp,
      satellite: r.satellite || "",
      instrument: r.instrument || "",
      acq_date: r.acq_date || "",
      acq_time: r.acq_time || "",
    }));
    const ws = XLSX.utils.json_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Hotspots");
    XLSX.writeFile(wb, "firs_hotspots_filtrados.xlsx");
  }

  function exportGeoJSON(){
    if (!lastData.length) return;
    const fc = { type:"FeatureCollection", features: lastData.map(r => ({
      type:"Feature",
      geometry:{ type:"Point", coordinates:[r.lon, r.lat] },
      properties:{ ...r }
    }))};
    const blob = new Blob([JSON.stringify(fc, null, 2)], { type:"application/geo+json;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "firs_hotspots_filtrados.geojson";
    document.body.appendChild(a);
    a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }

  // GEOESTATS
  function normalCdf(z){
    const sign = z < 0 ? -1 : 1;
    z = Math.abs(z) / Math.sqrt(2);
    const t = 1 / (1 + 0.3275911 * z);
    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429;
    const erf = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
    const cdf = 0.5 * (1 + sign * erf);
    return cdf;
  }

  function linearRegression(xs, ys){
    const n = xs.length;
    if (n < 2) return { a: 0, b: ys[0] ?? 0, r2: 0 };
    const meanX = xs.reduce((s,v)=>s+v,0)/n;
    const meanY = ys.reduce((s,v)=>s+v,0)/n;
    let num = 0, den = 0;
    for (let i=0;i<n;i++){
      num += (xs[i]-meanX)*(ys[i]-meanY);
      den += (xs[i]-meanX)*(xs[i]-meanX);
    }
    const a = den === 0 ? 0 : num/den;
    const b = meanY - a*meanX;
    let ssTot = 0, ssRes = 0;
    for (let i=0;i<n;i++){
      const yHat = a*xs[i] + b;
      ssTot += (ys[i]-meanY)**2;
      ssRes += (ys[i]-yHat)**2;
    }
    const r2 = ssTot === 0 ? 0 : 1 - (ssRes/ssTot);
    return { a, b, r2 };
  }

  function buildDailySeries(rows){
    const byDate = new Map();
    const byDateFrp = new Map();
    for (const r of rows){
      const d = r.acq_date || (r.datetime_utc ? r.datetime_utc.slice(0,10) : null);
      if (!d) continue;
      byDate.set(d, (byDate.get(d) || 0) + 1);
      byDateFrp.set(d, (byDateFrp.get(d) || 0) + (Number.isFinite(r.frp) ? r.frp : 0));
    }
    const dates = Array.from(byDate.keys()).sort();
    const counts = dates.map(d => byDate.get(d) || 0);
    const frps = dates.map(d => +(byDateFrp.get(d) || 0).toFixed(3));
    return { dates, counts, frps };
  }

  function sampleRows(rows, maxN){
    if (rows.length <= maxN) return rows;
    const copy = rows.slice();
    for (let i = copy.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy.slice(0, maxN);
  }

  function kmDistance(a, b){
    return turf.distance(turf.point([a.lon, a.lat]), turf.point([b.lon, b.lat]), { units: "kilometers" });
  }

  function computeNearestNeighborStats(points, areaKm2){
    const n = points.length;
    if (n < 2 || !areaKm2 || areaKm2 <= 0) return null;

    const nn = [];
    for (let i=0;i<n;i++){
      let best = Infinity;
      for (let j=0;j<n;j++){
        if (i===j) continue;
        const d = kmDistance(points[i], points[j]);
        if (d < best) best = d;
      }
      if (Number.isFinite(best)) nn.push(best);
    }

    const rObs = nn.reduce((a,b)=>a+b,0)/nn.length;
    const lam = n / areaKm2;
    const rExp = 0.5 / Math.sqrt(lam);

    const se = 0.26136 / Math.sqrt(n * lam);
    const z = se > 0 ? (rObs - rExp) / se : null;
    const p = (z == null) ? null : 2 * (1 - normalCdf(Math.abs(z)));

    return { n, areaKm2, lam, rObs, rExp, nni: rObs/rExp, z, p, nn };
  }

  function computeRipleyL(points, areaKm2, rMaxKm=20, bins=25){
    const n = points.length;
    if (n < 2 || !areaKm2 || areaKm2 <= 0) return null;

    const dr = rMaxKm / bins;
    const hist = new Array(bins).fill(0);

    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        const d = kmDistance(points[i], points[j]);
        if (d <= rMaxKm){
          const k = Math.min(bins-1, Math.floor(d / dr));
          hist[k] += 1;
        }
      }
    }

    const cum = [];
    let s = 0;
    for (let k=0;k<bins;k++){ s += hist[k]; cum.push(s); }

    const rs = [];
    const L = [];
    for (let k=0;k<bins;k++){
      const r = (k+1) * dr;
      rs.push(r);
      const pairLE = cum[k];
      const K = (areaKm2 / (n*(n-1))) * (2 * pairLE);
      L.push(Math.sqrt(K / Math.PI) - r);
    }
    return { rs, L };
  }

  function randomPointsInPolygon(n, poly, bbox){
    const pts = [];
    let attempts = 0;
    const maxAttempts = n * 120;
    while (pts.length < n && attempts < maxAttempts){
      const x = bbox[0] + Math.random() * (bbox[2]-bbox[0]);
      const y = bbox[1] + Math.random() * (bbox[3]-bbox[1]);
      const p = turf.point([x,y]);
      if (turf.booleanPointInPolygon(p, poly)){
        pts.push({ lon:x, lat:y });
      }
      attempts++;
    }
    return pts;
  }

  async function ripleyMonteCarlo(obsPts, study, rMaxKm=20, bins=25){
    const n = obsPts.length;
    if (n < 10) return null;

    let sims = 99;
    if (n > 200) sims = 39;
    if (n > 350) sims = 19;

    const obs = computeRipleyL(obsPts, study.areaKm2, rMaxKm, bins);
    if (!obs) return null;

    const upper = new Array(obs.L.length).fill(-Infinity);
    const lower = new Array(obs.L.length).fill(Infinity);

    const obsMax = Math.max(...obs.L);
    const obsMin = Math.min(...obs.L);

    let geMax = 0;
    let leMin = 0;

    for (let s=0; s<sims; s++){
      const simPts = randomPointsInPolygon(n, study.poly, study.bbox);
      if (simPts.length < n) continue;

      const sim = computeRipleyL(simPts, study.areaKm2, rMaxKm, bins);
      if (!sim) continue;

      for (let i=0;i<sim.L.length;i++){
        upper[i] = Math.max(upper[i], sim.L[i]);
        lower[i] = Math.min(lower[i], sim.L[i]);
      }

      const mx = Math.max(...sim.L);
      const mn = Math.min(...sim.L);
      if (mx >= obsMax) geMax++;
      if (mn <= obsMin) leMin++;
    }

    const pCluster = (geMax + 1) / (sims + 1);
    const pRegular = (leMin + 1) / (sims + 1);

    return { sims, obs, upper, lower, pCluster, pRegular };
  }

  function computeSDE(points){
    const n = points.length;
    if (n < 2) return null;
    const lat0 = points.reduce((a,p)=>a+p.lat,0)/n;
    const lon0 = points.reduce((a,p)=>a+p.lon,0)/n;

    const kx = 111.32 * Math.cos(lat0 * Math.PI/180);
    const ky = 110.574;

    const xs = points.map(p => (p.lon - lon0) * kx);
    const ys = points.map(p => (p.lat - lat0) * ky);

    let sdx2 = 0, sdy2 = 0, sxy = 0;
    for (let i=0;i<n;i++){
      sdx2 += xs[i]*xs[i];
      sdy2 += ys[i]*ys[i];
      sxy  += xs[i]*ys[i];
    }
    const varx = sdx2/n;
    const vary = sdy2/n;
    const cov  = sxy/n;

    const tr = varx + vary;
    const det = varx*vary - cov*cov;
    const disc = Math.max(0, tr*tr - 4*det);
    const l1 = (tr + Math.sqrt(disc)) / 2;
    const l2 = (tr - Math.sqrt(disc)) / 2;

    const major = Math.sqrt(Math.max(0,l1));
    const minor = Math.sqrt(Math.max(0,l2));
    const angle = 0.5 * Math.atan2(2*cov, (varx - vary));
    const az = (angle * 180/Math.PI + 360) % 180;

    const sd = Math.sqrt((varx + vary));
    return { sd, major, minor, az };
  }

  function computeVariogram(points, rMaxKm=20, bins=20){
    const usable = points.filter(p => Number.isFinite(p.frp));
    const n = usable.length;
    if (n < 6) return null;

    const dr = rMaxKm / bins;
    const count = new Array(bins).fill(0);
    const sumSq = new Array(bins).fill(0);

    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        const d = kmDistance(usable[i], usable[j]);
        if (d <= rMaxKm){
          const k = Math.min(bins-1, Math.floor(d / dr));
          const diff = usable[i].frp - usable[j].frp;
          sumSq[k] += diff*diff;
          count[k] += 1;
        }
      }
    }

    const hs = [];
    const gamma = [];
    for (let k=0;k<bins;k++){
      const h = (k+0.5)*dr;
      hs.push(+h.toFixed(3));
      if (count[k] > 0){
        gamma.push(0.5 * (sumSq[k]/count[k]));
      } else {
        gamma.push(null);
      }
    }

    return { hs, gamma };
  }

  function updateGeoKPIs(geo){
    $("g_area").textContent = geo.areaKm2 != null ? geo.areaKm2.toFixed(2) : "—";
    $("g_area_s").textContent = geo.areaLabel || "recorte actual";

    $("g_n").textContent = `${geo.nSample} / ${geo.nTotal}`;
    $("g_n_s").textContent = geo.sampleNote || "";

    $("g_lambda").textContent = geo.lam != null ? geo.lam.toFixed(4) : "—";

    $("g_nni").textContent = geo.nni != null ? geo.nni.toFixed(3) : "—";
    $("g_nni_s").textContent = geo.nniText || "—";

    $("g_z").textContent = geo.z != null ? geo.z.toFixed(2) : "—";
    $("g_p").textContent = geo.p != null ? `p: ${geo.p.toExponential(2)}` : "p: —";

    $("g_lmax").textContent = geo.lmax != null ? `${geo.lmax.toFixed(3)} km` : "—";
    $("g_lr").textContent = geo.lAt != null ? `escala r: ${geo.lAt.toFixed(2)} km` : "escala r: — km";

    $("g_mc").textContent = geo.mcLabel || "—";
    $("g_mc_s").textContent = geo.mcP || "p(cluster): —";

    $("g_sd").textContent = geo.sd != null ? `${geo.sd.toFixed(2)} km` : "—";
    $("g_sde").textContent = geo.sdeText || "elipse: —";
  }

  function updateChartsAndGeo(rows){
    // Temporal + tendencia
    const { dates, counts, frps } = buildDailySeries(rows);
    const xs = dates.map((_,i)=>i);
    const reg = linearRegression(xs, counts);
    const trend = xs.map(x => reg.a*x + reg.b);
    $("trendNote").textContent = `Tendencia (detecciones/día, OLS): y = ${reg.a.toFixed(3)}x + ${reg.b.toFixed(3)} · R² = ${Math.max(0, Math.min(1, reg.r2)).toFixed(3)}`;

    const ctx1 = $("chartDaily").getContext("2d");
    if (chartDaily) chartDaily.destroy();
    chartDaily = new Chart(ctx1, {
      type: "line",
      data: {
        labels: dates,
        datasets: [
          { label: "Detecciones/día", data: counts, tension: 0.25 },
          { label: "Tendencia (OLS)", data: trend, tension: 0, borderDash: [6,6], pointRadius: 0 },
          { label: "FRP/día (MW)", data: frps, yAxisID: "y2", tension: 0.25 }
        ]
      },
      options: {
        responsive: true,
        plugins: { legend: { position: "bottom" } },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: "Detecciones" } },
          y2: { beginAtZero: true, position: "right", grid: { drawOnChartArea: false }, title: { display: true, text: "FRP (MW)" } }
        }
      }
    });

    // Sensor chart
    const bySensor = {};
    for (const r of rows){ bySensor[r.source || "—"] = (bySensor[r.source || "—"] || 0) + 1; }
    const sensors = Object.keys(bySensor).sort();
    const vals = sensors.map(s => bySensor[s]);
    const total = vals.reduce((a,b)=>a+b,0) || 1;
    const perc = vals.map(v => 100*v/total);

    const ctx2 = $("chartSensors").getContext("2d");
    if (chartSensors) chartSensors.destroy();
    chartSensors = new Chart(ctx2, {
      type: "bar",
      data: { labels: sensors, datasets: [{ label:"Detecciones", data: vals }, { label:"%", data: perc.map(v=>+v.toFixed(2)) }] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });

    // Geo stats
    const study = getStudyPolygonForCSR();
    const areaKm2 = study.areaKm2;

    const MAX_GEO_N = 350;
    const ptsAll = rows.map(r => ({ lat:r.lat, lon:r.lon, frp: (Number.isFinite(r.frp)?r.frp:null) }))
                      .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon));
    const pts = sampleRows(ptsAll, MAX_GEO_N);

    const geo = {
      areaKm2,
      areaLabel: study.label,
      nSample: pts.length,
      nTotal: ptsAll.length,
      sampleNote: ptsAll.length > pts.length ? `muestra aleatoria (cap=${MAX_GEO_N})` : "sin muestreo",
      lam: (areaKm2 && pts.length) ? (pts.length/areaKm2) : null,
      nni: null, z: null, p: null, nniText: "—",
      lmax: null, lAt: null,
      mcLabel: "—", mcP: "p(cluster): —",
      sd: null, sdeText: null
    };

    if (!areaKm2 || pts.length < 10){
      updateGeoKPIs(geo);
      return;
    }

    const nni = computeNearestNeighborStats(pts, areaKm2);
    if (nni){
      geo.nni = nni.nni;
      geo.z = nni.z;
      geo.p = nni.p;
      const pattern = (nni.nni < 1) ? "cluster" : (nni.nni > 1 ? "regular" : "CSR~1");
      geo.nniText = `r̄obs=${nni.rObs.toFixed(3)} km · r̄exp=${nni.rExp.toFixed(3)} km · ${pattern}`;
    }

    const sde = computeSDE(pts);
    if (sde){
      geo.sd = sde.sd;
      geo.sdeText = `a=${sde.major.toFixed(2)} km · b=${sde.minor.toFixed(2)} km · az=${sde.az.toFixed(1)}°`;
    }

    const rip = computeRipleyL(pts, areaKm2, 20, 25);
    if (rip){
      let imax = 0;
      for (let i=1;i<rip.L.length;i++){
        if (rip.L[i] > rip.L[imax]) imax = i;
      }
      geo.lmax = rip.L[imax];
      geo.lAt = rip.rs[imax];
    }

    updateGeoKPIs(geo);

    // NN chart
    if (nni && nni.nn?.length){
      const nnSorted = nni.nn.slice().sort((a,b)=>a-b);
      const maxD = Math.min(10, nnSorted[Math.floor(nnSorted.length*0.98)] || 10);
      const bins = 20;
      const step = maxD / bins;
      const h = new Array(bins).fill(0);
      for (const d of nnSorted){
        if (d > maxD) continue;
        const k = Math.min(bins-1, Math.floor(d/step));
        h[k] += 1;
      }
      const xh = h.map((_,k)=>+( (k+0.5)*step ).toFixed(3));
      const ctxNN = $("chartNN").getContext("2d");
      if (chartNN) chartNN.destroy();
      chartNN = new Chart(ctxNN, {
        type: "bar",
        data: { labels: xh.map(v=>String(v)), datasets: [{ label: "Vecino más cercano (km) — histograma", data: h }] },
        options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true }, x:{ title:{ display:true, text:"km" } } } }
      });
    }

    // Variogram
    const vario = computeVariogram(pts, 20, 20);
    const ctxV = $("chartVariogram").getContext("2d");
    if (chartVariogram) chartVariogram.destroy();
    chartVariogram = new Chart(ctxV, {
      type: "line",
      data: {
        labels: vario ? vario.hs.map(v=>String(v)) : [],
        datasets: vario ? [{ label: "Variograma experimental γ(h) de FRP", data: vario.gamma.map(v => v==null?null:+v.toFixed(4)), tension: 0.1 }] : []
      },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ title:{ display:true, text:"γ(h)" } }, x:{ title:{ display:true, text:"h (km)" } } } }
    });

    // Ripley with envelope
    (async () => {
      const ctxR = $("chartRipley").getContext("2d");
      if (chartRipley) chartRipley.destroy();

      const mc = await ripleyMonteCarlo(pts, study, 20, 25);
      if (!mc){
        chartRipley = new Chart(ctxR, {
          type: "line",
          data: { labels: rip ? rip.rs.map(r=>String(r.toFixed(3))) : [], datasets: rip ? [{ label: "L(r) observado", data: rip.L.map(v=>+v.toFixed(4)), tension:0.1 }] : [] },
          options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ title:{ display:true, text:"L(r) (km)" } }, x:{ title:{ display:true, text:"r (km)" } } } }
        });
        return;
      }

      let label = "CSR: no concluyente";
      if (mc.pCluster < 0.05) label = "CSR: cluster (p<0.05)";
      else if (mc.pRegular < 0.05) label = "CSR: regular (p<0.05)";

      geo.mcLabel = label;
      geo.mcP = `p(cluster): ${mc.pCluster.toExponential(2)} · p(regular): ${mc.pRegular.toExponential(2)} · sims=${mc.sims}`;
      updateGeoKPIs(geo);

      chartRipley = new Chart(ctxR, {
        type: "line",
        data: {
          labels: mc.obs.rs.map(r=>String(r.toFixed(3))),
          datasets: [
            { label: "L(r) observado", data: mc.obs.L.map(v=>+v.toFixed(4)), tension: 0.1 },
            { label: "Envelope superior (CSR)", data: mc.upper.map(v=>+v.toFixed(4)), tension: 0.1, pointRadius: 0, borderDash: [6,6] },
            { label: "Envelope inferior (CSR)", data: mc.lower.map(v=>+v.toFixed(4)), tension: 0.1, pointRadius: 0, borderDash: [6,6] },
          ]
        },
        options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ title:{ display:true, text:"L(r) (km)" } }, x:{ title:{ display:true, text:"r (km)" } } } }
      });
    })();
  }

  // MAIN RUN
  let autoTimer = null;

  async function checkHealth(){
    const dot = $("dot");
    try{
      const r = await fetch(`${PROXY_BASE}/health`);
      const j = await r.json();
      $("pillText").textContent = j.ok ? "Proxy: OK" : "Proxy: error";
      if (dot) dot.style.background = j.ok ? "#2fd08f" : "#f0b24d";
    }catch(e){
      $("pillText").textContent = "Proxy: no responde";
      if (dot) dot.style.background = "#f0b24d";
    }
  }

  async function run(){
    const days = Number($("days").value);
    const sensors = getSensors();
    const bboxArr = getBBoxFromUI();
    const limit = Number($("limit").value);
    const conf = $("conf").value;

    if (!sensors.length) return setStatus("Selecciona al menos un sensor.");
    if (!bboxArr) return setStatus("BBOX inválido. Revisa el modo seleccionado.");

    const bbox = bboxStr(bboxArr);
    const url = `${PROXY_BASE}/api/firms?bbox=${encodeURIComponent(bbox)}&days=${days}&sensors=${encodeURIComponent(sensors.join(","))}&limit=${limit}`;

    setStatus(`Consultando FIRMS...\n${url}`);

    const t0 = performance.now();
    const r = await fetch(url);
    const j = await r.json();
    const ms = Math.round(performance.now() - t0);

    if (!r.ok && !j.ok){
      const extra = (j?.error && String(j.error).includes("1..30"))
        ? "\n\nNota: para 60/90 días, sube MAX_DAYS a 90 en el Worker y redeploy."
        : "";
      return setStatus(`Error (${r.status}).\n${j.error || "Sin detalle"}${extra}`);
    }

    setStatus(`OK. Total (dedupe): ${j.total}. Filas devueltas: ${j.rows.length}. (${ms} ms)`);

    let rows = (j.rows || []).filter(rr => conf === "all" ? true : confClass(rr.confidence) === conf);
    rows = pointFilterByPolygon(rows);
    rows.sort((a,b) => (a.datetime_utc || "") < (b.datetime_utc || "") ? 1 : -1);

    lastData = rows;

    updateMap(lastData);
    buildTable(lastData);
    updateKPIs(j, lastData);
    updateChartsAndGeo(lastData);
    applyFilter();

    $("lastRun").textContent = `Última actualización: ${new Date().toLocaleString("es-GT")}`;

    const clipMode = $("clipMode").value;
    if (["muni","micro","ap"].includes(clipMode)){
      renderPolyOverlay(clipMode, $("polySelect").value || "all");
    } else {
      overlayGroup.clearLayers();
    }

    setTimeout(() => map.invalidateSize(), 120);
  }

  function setupAuto(){
    if (autoTimer) clearInterval(autoTimer);
    if ($("auto").checked) autoTimer = setInterval(run, 10 * 60 * 1000);
  }

  async function updateClipUI(){
    const mode = $("clipMode").value;

    $("manualBBox").style.display = (mode === "bbox_manual") ? "block" : "none";
    const isPoly = ["muni","micro","ap"].includes(mode);
    $("polyPick").style.display = isPoly ? "block" : "none";

    if (!isPoly){
      overlayGroup.clearLayers();
      return;
    }

    try{
      await ensurePolyLoaded(mode);
      populatePolySelect(mode);
      renderPolyOverlay(mode, $("polySelect").value || "all");
      const bb = getBBoxFromUI();
      if (bb) fitToBBox(bb);
    }catch(err){
      setStatus(`Error cargando capa SIG.\n${String(err)}`);
    }
  }

  // EVENTS
  $("clipMode").addEventListener("change", () => updateClipUI());
  $("polySelect").addEventListener("change", () => {
    const mode = $("clipMode").value;
    if (["muni","micro","ap"].includes(mode)){
      renderPolyOverlay(mode, $("polySelect").value || "all");
      updateChartsAndGeo(lastData);
    }
  });

  $("btnRun").addEventListener("click", run);
  $("btnFit").addEventListener("click", () => {
    const bb = getBBoxFromUI();
    if (!bb) return setStatus("No hay BBOX válido para ajustar.");
    fitToBBox(bb);
    setStatus("Mapa ajustado al recorte.");
  });

  $("btnCSV").addEventListener("click", exportCSV);
  $("btnExcel").addEventListener("click", exportExcel);
  $("btnGeoJSON").addEventListener("click", exportGeoJSON);

  $("btnClear").addEventListener("click", () => { $("q").value=""; applyFilter(); });
  $("q").addEventListener("input", applyFilter);
  $("auto").addEventListener("change", setupAuto);

  (async function init(){
    fitToBBox(BBOX_PRESETS.solola);
    await checkHealth();
    setupAuto();
    await updateClipUI();
    await run();
  })();
})();
</script>
</body>
</html>
