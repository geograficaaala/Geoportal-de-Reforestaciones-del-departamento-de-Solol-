<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Incendios — Dashboard FIRMS (NRT) · Sololá</title>
  <meta name="description" content="Dashboard SIG de anomalías térmicas (FIRMS NRT): filtros por periodo, sensores y recortes espaciales (BBOX, municipios, microcuencas y áreas protegidas) con análisis geoestadístico." />

  <!-- Leaflet (sin SRI para evitar bloqueos) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin=""></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- SheetJS (Excel export) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <style>
    :root{
      /* Pasteles “fuego” */
      --bg-0:#fff7f0;
      --bg-1:#fff2e6;
      --card:rgba(255,255,255,.92);
      --card2:rgba(255,255,255,.98);
      --ink:#2b1d12;
      --muted:#6a4e3c;
      --brand:#ff7a45;
      --stroke:rgba(32,18,10,.12);

      --hi:#ff5a5f;
      --nom:#ffb703;
      --low:#6c757d;

      --shadow: 0 14px 40px rgba(40,20,10,.12);
      --shadow-sm: 0 10px 22px rgba(40,20,10,.10);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      color:var(--ink);
      background:
        radial-gradient(900px 560px at 0% 0%, rgba(255,122,69,.18), transparent 62%),
        radial-gradient(900px 560px at 100% 0%, rgba(255,183,3,.16), transparent 62%),
        linear-gradient(180deg, var(--bg-0), var(--bg-1));
      min-height:100vh;
    }

    header{
      position: sticky;
      top: 0;
      z-index: 50;
      backdrop-filter: blur(10px);
      background: rgba(255,255,255,.78);
      border-bottom: 1px solid var(--stroke);
    }
    .header-wrap{
      padding: 10px 14px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{ display:flex; flex-direction:column; gap:2px; min-width: 260px; }
    .title h1{ margin:0; font-size: 15px; letter-spacing:.2px; }
    .title .sub{ font-size:12px; color:var(--muted); }

    .chips{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 999px;
      box-shadow: var(--shadow-sm);
      font-size:12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: #2fd08f;
      box-shadow: 0 0 0 4px rgba(47,208,143,.18);
    }

    main{
      display:grid;
      grid-template-columns: 390px 1fr;
      gap:14px;
      padding: 14px 14px 18px;
      align-items:stretch;
    }
    .panel{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-width:0;
    }
    .panel h2{
      margin:0;
      padding:12px 14px;
      font-size:13px;
      color:#3a2416;
      border-bottom: 1px solid rgba(0,0,0,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.82));
    }
    .panel .content{ padding: 12px 14px 14px; }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    select, input[type="text"], input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      outline:none;
    }
    input[type="checkbox"]{ transform: translateY(1px); }

    .checks{
      display:grid; gap:8px;
      padding:10px;
      background:#fff;
      border:1px solid rgba(0,0,0,.14);
      border-radius:12px;
    }
    .checks .row{ display:flex; gap:8px; align-items:flex-start; font-size:12.5px; color:#3a2416; }
    .checks small{ display:block; color:var(--muted); margin-top:2px; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      border:none; cursor:pointer;
      padding:10px 12px;
      border-radius: 12px;
      font-weight:800; font-size:12.5px;
    }
    .btn-primary{ background: linear-gradient(135deg, var(--brand), #ffb45a); color:#fff; }
    .btn-ghost{ background:#fff; border:1px solid rgba(0,0,0,.14); color:#2b1d12; }

    .status{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:#fff;
      border:1px dashed rgba(255,122,69,.35);
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }

    .notes{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
      border:1px solid rgba(0,0,0,.10);
      color: var(--muted);
      font-size:12px;
      line-height:1.4;
    }
    .notes ul{ margin:8px 0 0; padding-left: 18px; }
    .notes li{ margin:6px 0; }

    .right{
      display:grid;
      grid-template-rows: auto auto 1fr;
      gap:14px;
      min-width:0;
    }

    .mapWrap{ padding:12px 14px 14px; position:relative; }
    #map{
      height: 520px;
      min-height: 520px;
      border-radius: var(--radius);
      background: #f6efe9;
      outline: 1px solid rgba(0,0,0,.06);
    }
    .mapError{
      display:none;
      position:absolute;
      inset: 16px 18px auto 18px;
      background: rgba(255,255,255,.96);
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: var(--shadow-sm);
      color: #7b3b1f;
      font-size: 12px;
      line-height: 1.35;
    }
    .mapError code{ background:#f3f3f3; padding:2px 6px; border-radius:8px; }

    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      padding: 0 14px 14px;
      font-size:12px; color:var(--muted);
    }
    .lg{
      display:flex; align-items:center; gap:6px;
      padding:6px 8px;
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:999px;
    }
    .sw{ width:10px; height:10px; border-radius:50%; }

    .kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
      padding: 12px 14px 14px;
    }
    .kpi{
      border:1px solid rgba(0,0,0,.10);
      border-radius: 14px;
      padding:10px;
      background:#fff;
      min-width:0;
    }
    .kpi .k{ font-size:11px; color:var(--muted); }
    .kpi .v{ font-size:16px; font-weight:950; margin-top:4px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    .analysisGrid{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:14px;
      min-width:0;
      padding-bottom: 14px;
    }
    .filters{ display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap:wrap; }
    .filters input{ flex:1; min-width: 220px; }

    .tableWrap{
      overflow:auto;
      max-height: 420px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.10);
      background:#fff;
    }
    table{ width:100%; border-collapse: collapse; font-size:12px; }
    thead th{
      position:sticky; top:0; z-index:1;
      background:#fff3e6;
      border-bottom:1px solid rgba(0,0,0,.10);
      text-align:left;
      padding:10px 8px;
      color:#3a2416;
      white-space:nowrap;
    }
    tbody td{
      border-bottom:1px solid rgba(0,0,0,.06);
      padding:8px 8px;
      color:#2b1d12;
      vertical-align:top;
      white-space:nowrap;
    }
    tbody tr:hover{ background:#fff7f0; cursor:pointer; }

    .hint{ font-size:12px; color:var(--muted); line-height:1.35; margin-top:8px; }
    .equations code{ background:#f3f3f3; padding:2px 6px; border-radius:8px; }
    .equations .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .hotspot{
      width:14px; height:14px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,.92);
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
    }

    footer{
      padding: 10px 14px 24px;
      color: var(--muted);
      font-size: 12px;
    }
    .footer-box{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px 14px;
    }
    .footer-logos{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      align-items:center;
      justify-content:center;
      margin-top:10px;
    }
    .footer-logos img{
      max-height: 44px;
      width: auto;
      object-fit: contain;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.06));
      background: rgba(255,255,255,.94);
      border-radius: 10px;
      padding: 4px 6px;
    }

    @media (max-width: 1100px){
      main{ grid-template-columns: 1fr; }
      .kpis{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .analysisGrid{ grid-template-columns: 1fr; }
      #map{ height: 440px; min-height: 440px; }
    }
  </style>
</head>

<body>
  <header>
    <div class="header-wrap">
      <div class="title">
        <h1>Incendios forestales — Anomalías térmicas (FIRMS NRT)</h1>
        <div class="sub">Sololá · Recortes SIG (BBOX / Municipios / Microcuencas / Áreas protegidas) · UTC</div>
      </div>

      <div class="chips">
        <div class="chip" title="Estado del proxy">
          <span class="dot" id="dot"></span>
          <span id="pillText">Proxy: sin verificar</span>
        </div>
        <div class="chip" title="Auto actualización">
          <input id="auto" type="checkbox" checked />
          <label for="auto" style="margin:0; cursor:pointer;">Auto (10 min)</label>
        </div>
        <div class="chip" id="lastRun">Última actualización: —</div>
      </div>
    </div>
  </header>

  <main>
    <!-- Left controls -->
    <section class="panel">
      <h2>Filtros</h2>
      <div class="content">
        <div class="grid2">
          <div>
            <label for="days">Período</label>
            <select id="days">
              <option value="1">24 horas (1 día)</option>
              <option value="3" selected>72 horas (3 días)</option>
              <option value="7">7 días</option>
              <option value="30">30 días</option>
              <option value="60">60 días</option>
              <option value="90">90 días</option>
            </select>
          </div>
          <div>
            <label for="clipMode">Recorte espacial</label>
            <select id="clipMode">
              <option value="bbox_solola" selected>Sololá (BBOX)</option>
              <option value="bbox_guatemala">Guatemala (BBOX)</option>
              <option value="bbox_map">Extensión del mapa (BBOX)</option>
              <option value="bbox_manual">BBOX personalizado</option>
              <option value="muni">Municipio (Sololá)</option>
              <option value="micro">Microcuenca (Atitlán)</option>
              <option value="ap">Área protegida</option>
            </select>
          </div>
        </div>

        <div id="manualBBox" style="display:none; margin-top:10px">
          <label>BBOX manual (west,south,east,north)</label>
          <div class="grid2">
            <input type="number" step="0.000001" id="w" placeholder="west (lon)">
            <input type="number" step="0.000001" id="e" placeholder="east (lon)">
          </div>
          <div style="height:8px"></div>
          <div class="grid2">
            <input type="number" step="0.000001" id="s" placeholder="south (lat)">
            <input type="number" step="0.000001" id="n" placeholder="north (lat)">
          </div>
        </div>

        <div id="polyPick" style="display:none; margin-top:10px">
          <label id="polyLabel">Selección</label>
          <select id="polySelect"></select>
          <div class="hint" id="polyHint"></div>
        </div>

        <div style="height:10px"></div>

        <label>Sensores (Near Real-Time)</label>
        <div class="checks">
          <div class="row">
            <input type="checkbox" id="s_snpp" checked>
            <div><b>VIIRS Suomi-NPP</b><small>VIIRS_SNPP_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_n20" checked>
            <div><b>VIIRS NOAA-20 (JPSS-1)</b><small>VIIRS_NOAA20_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_n21" checked>
            <div><b>VIIRS NOAA-21 (JPSS-2)</b><small>VIIRS_NOAA21_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_modis" checked>
            <div><b>MODIS (Terra/Aqua) NRT</b><small>MODIS_NRT</small></div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="grid2">
          <div>
            <label for="conf">Confianza del algoritmo</label>
            <select id="conf">
              <option value="all" selected>Todas</option>
              <option value="high">Alta</option>
              <option value="nominal">Nominal/Media</option>
              <option value="low">Baja</option>
            </select>
          </div>
          <div>
            <label for="limit">Límite filas</label>
            <select id="limit">
              <option value="2000">2,000</option>
              <option value="10000" selected>10,000</option>
              <option value="20000">20,000</option>
              <option value="50000">50,000</option>
            </select>
          </div>
        </div>

        <div class="btns">
          <button class="btn-primary" id="btnRun">Actualizar</button>
          <button class="btn-ghost" id="btnFit">Ajustar mapa</button>
          <button class="btn-ghost" id="btnCSV">CSV</button>
          <button class="btn-ghost" id="btnExcel">Excel</button>
          <button class="btn-ghost" id="btnGeoJSON">GeoJSON</button>
        </div>

        <div class="status" id="status">Listo.</div>

        <div class="notes">
          <b>Notas técnicas (FIRMS Active Fire / NRT)</b>
          <ul>
            <li>Hotspots ≠ perímetro. VIIRS (Suomi‑NPP / NOAA‑20 / NOAA‑21) y MODIS (Terra/Aqua) detectan <b>fuego activo/anomalía térmica</b>.</li>
            <li>La observación depende del <b>paso orbital</b> y de nubosidad/humo; puede haber omisiones y múltiples detecciones del mismo evento.</li>
            <li>Resolución aproximada: <b>VIIRS ~375 m</b> y <b>MODIS ~1 km</b>. La ubicación es una aproximación del píxel detectado.</li>
            <li>FRP (MW) es un indicador radiativo de energía del fuego (no es área quemada).</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- Right -->
    <section class="right">
      <section class="panel">
        <h2>Mapa</h2>
        <div class="mapWrap">
          <div id="map"></div>
          <div class="mapError" id="mapError"></div>
        </div>
        <div class="legend">
          <div class="lg"><span class="sw" style="background:var(--hi)"></span> Alta</div>
          <div class="lg"><span class="sw" style="background:var(--nom)"></span> Nominal/Media</div>
          <div class="lg"><span class="sw" style="background:var(--low)"></span> Baja</div>
        </div>
      </section>

      <section class="panel">
        <h2>KPIs</h2>
        <div class="kpis">
          <div class="kpi"><div class="k">Detecciones (filtradas)</div><div class="v" id="k_total">—</div></div>
          <div class="kpi"><div class="k">Alta confianza</div><div class="v" id="k_high">—</div></div>
          <div class="kpi"><div class="k">FRP total (MW)</div><div class="v" id="k_frp">—</div></div>
          <div class="kpi"><div class="k">Última detección (UTC)</div><div class="v" id="k_last">—</div></div>
        </div>
      </section>

      <section class="panel">
        <h2>Análisis</h2>
        <div class="content">
          <div class="analysisGrid">
            <div>
              <div class="filters">
                <input id="q" type="text" placeholder="Filtrar tabla (zona, sensor, fecha, satélite…)" />
                <button class="btn-ghost" id="btnClear">Limpiar filtro</button>
              </div>

              <div class="tableWrap">
                <table id="tbl">
                  <thead>
                    <tr>
                      <th>UTC</th>
                      <th>Zona</th>
                      <th>Sensor</th>
                      <th>Conf.</th>
                      <th>Lat</th>
                      <th>Lon</th>
                      <th>FRP</th>
                    </tr>
                  </thead>
                  <tbody></tbody>
                </table>
              </div>

              <div class="hint" id="tableNote"></div>

              <div class="notes equations">
                <b>Geoestadística (interpretación)</b>
                <div class="hint">
                  <span class="mono">λ = n/A</span> (intensidad, puntos/km²) ·
                  <span class="mono">r̄<sub>exp</sub> = 0.5/√λ</span> (CSR) ·
                  <span class="mono">NNI = r̄<sub>obs</sub>/r̄<sub>exp</sub></span> ·
                  <span class="mono">K(r) = (A/(n(n−1)))·2·#{d≤r}</span> ·
                  <span class="mono">L(r)=√(K(r)/π)−r</span> ·
                  <span class="mono">γ(h)=½·mean[(z<sub>i</sub>−z<sub>j</sub>)²]</span> (variograma)
                </div>
                <div class="hint" id="geoStatsNote">—</div>
              </div>
            </div>

            <div>
              <canvas id="chartDaily" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartSensors" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartRipley" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartVariogram" height="160"></canvas>
              <div style="height:12px"></div>
              <canvas id="chartNN" height="160"></canvas>
              <div class="hint" id="trendNote"></div>
            </div>
          </div>
        </div>
      </section>
    </section>
  </main>

  <!-- Logos institucionales (abajo) -->
  <footer>
    <div class="footer-box">
      <div style="text-align:center; font-weight:800;">Eje de Bosques · CODEMA Sololá · Instituciones participantes</div>
      <div class="footer-logos" aria-label="Logos institucionales">
        <img src="../../BOSQUE.png" alt="Eje de Bosques">
        <img src="../../CODEMA%20%282%29.png" alt="CODEMA Sololá">
        <img src="../../marn.png" alt="MARN">
        <img src="../../maga.png" alt="MAGA">
        <img src="../../inab.png" alt="INAB">
        <img src="../../conap.png" alt="CONAP">
        <img src="../../amsclae.png" alt="AMSCLAE">
        <img src="../../conred.png" alt="CONRED">
        <img src="../../cea.png" alt="CEA - UVG">
        <img src="../../aala_logo.png" alt="Amigos del Lago de Atitlán">
        <img src="../../vivamos.png" alt="Vivamos Mejor Guatemala">
        <img src="../../aires.png" alt="AIR">
      </div>
      <div style="text-align:center; margin-top:10px;">
        Fuentes: NASA FIRMS (LANCE) — Active Fire (NRT) · Geoprocesos en navegador (Turf.js) · Visualización (Leaflet/Chart.js)
      </div>
    </div>
  </footer>

<script>
(() => {
  // ======================
  // CONFIG
  // ======================
  const PROXY_BASE = "https://royal-dust-e52cfirms-proxy-solola.sgeograficaaala.workers.dev";
  const LAYER_SOURCES = {
    muni:  { url: "./data/municipios_solola.geojson", label: "Municipio (Sololá)" },
    micro: { url: "./data/microcuencas_atitlan.geojson", label: "Microcuenca (Atitlán)" },
    ap:    { url: "./data/areas_protegidas.geojson", label: "Área protegida" },
  };
  const BBOX_PRESETS = {
    solola:    [-91.586608, 14.495833, -91.040503, 14.992742],
    guatemala: [-92.3592, 13.5235, -88.0458, 18.0436],
  };

  const $ = (id) => document.getElementById(id);
  const mapError = $("mapError");

  function showMapError(msg){
    if (!mapError) return;
    mapError.style.display = "block";
    mapError.innerHTML = msg;
  }

  // Captura errores JS y los muestra en pantalla
  window.addEventListener("error", (e) => {
    const m = (e && e.message) ? e.message : "Error desconocido";
    showMapError(`Error JavaScript: <code>${m}</code><br/>Abre DevTools → Console para ver detalles.`);
  });

  function setStatus(msg){ $("status").textContent = msg; }
  function fmt(n, d=0){
    if (n === null || n === undefined || Number.isNaN(n)) return "—";
    return new Intl.NumberFormat("es-GT",{ maximumFractionDigits:d }).format(n);
  }

  function confClass(c){
    const s = String(c ?? "").trim().toLowerCase();
    const n = Number(s);
    if (!Number.isNaN(n)){
      if (n >= 80) return "high";
      if (n >= 30) return "nominal";
      return "low";
    }
    if (["h","high"].includes(s)) return "high";
    if (["n","nominal","m","medium"].includes(s)) return "nominal";
    if (["l","low"].includes(s)) return "low";
    return "unknown";
  }
  function confColor(c){
    const k = confClass(c);
    const css = getComputedStyle(document.documentElement);
    if (k === "high") return css.getPropertyValue("--hi").trim();
    if (k === "nominal") return css.getPropertyValue("--nom").trim();
    return css.getPropertyValue("--low").trim();
  }
  function bboxStr(arr){ return arr.map(v => Number(v.toFixed(6))).join(","); }
  function getSensors(){
    const out = [];
    if ($("s_snpp").checked) out.push("VIIRS_SNPP_NRT");
    if ($("s_n20").checked) out.push("VIIRS_NOAA20_NRT");
    if ($("s_n21").checked) out.push("VIIRS_NOAA21_NRT");
    if ($("s_modis").checked) out.push("MODIS_NRT");
    return out;
  }

  // ======================
  // MAP INIT
  // ======================
  if (!window.L){
    showMapError(`No se cargó Leaflet (<code>L</code>). Revisa tu conexión o si un bloqueador está deteniendo <code>unpkg.com</code>.`);
    return;
  }
  if (!$("map")){
    showMapError(`No se encontró el contenedor <code>#map</code>.`);
    return;
  }

  let map, clusters, overlayGroup;
  const iconCache = new Map();
  function markerIcon(color){
    if (iconCache.has(color)) return iconCache.get(color);
    const icon = L.divIcon({
      className: "",
      html: `<div class="hotspot" style="background:${color}"></div>`,
      iconSize: [14,14],
      iconAnchor: [7,7],
      popupAnchor: [0,-8]
    });
    iconCache.set(color, icon);
    return icon;
  }

  try{
    map = L.map("map", { zoomControl: true }).setView([14.77, -91.18], 10);

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors',
    }).addTo(map);

    const imagery = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      maxZoom: 19,
      attribution: "Tiles &copy; Esri",
    });

    L.control.layers({ "OSM": osm, "Satélite (Esri)": imagery }, {}, { position: "topleft" }).addTo(map);

    // Fallback si MarkerCluster no cargó
    if (typeof L.markerClusterGroup === "function"){
      clusters = L.markerClusterGroup({ chunkedLoading: true, showCoverageOnHover: false, maxClusterRadius: 55 });
    } else {
      clusters = L.layerGroup();
      setStatus("Aviso: no se cargó Leaflet.markercluster; usando capa simple.");
    }
    map.addLayer(clusters);

    overlayGroup = L.layerGroup().addTo(map);

    // Asegura render
    setTimeout(() => map.invalidateSize(), 250);
  }catch(err){
    showMapError(`No se pudo inicializar el mapa: <code>${String(err)}</code>`);
    return;
  }

  // ======================
  // POLY DATA
  // ======================
  const polyState = {
    muni:  { loaded:false, gj:null, items:[], nameField:null },
    micro: { loaded:false, gj:null, items:[], nameField:null },
    ap:    { loaded:false, gj:null, items:[], nameField:null },
  };

  function pickNameField(gj){
    if (!gj?.features?.length) return null;
    const preferred = ["NOMBRE","Nombre","nombre","MUNICIPIO","municipio","NOM_MUNI","MICROCUENCA","microcuenca","NOM_AREA","NAME","name"];
    const props = gj.features.map(f => f.properties || {});
    for (const key of preferred){
      let hits = 0;
      for (const p of props){
        const v = p[key];
        if (typeof v === "string" && v.trim()) hits++;
      }
      if (hits >= Math.max(2, Math.floor(props.length * 0.2))) return key;
    }
    const first = props[0] || {};
    for (const [k,v] of Object.entries(first)){
      if (typeof v === "string" && v.trim()) return k;
    }
    return null;
  }

  function cleanName(v){
    const s = (v == null) ? "" : String(v).trim();
    return s || "—";
  }

  async function ensurePolyLoaded(mode){
    const st = polyState[mode];
    if (!st || st.loaded) return;

    const src = LAYER_SOURCES[mode];
    const r = await fetch(src.url, { cache: "no-store" });
    if (!r.ok) throw new Error(`No se pudo cargar ${src.url} (HTTP ${r.status})`);
    const gj = await r.json();

    st.gj = gj;
    st.nameField = pickNameField(gj);

    const items = [];
    for (let i = 0; i < (gj.features || []).length; i++){
      const f = gj.features[i];
      const id = f.id ?? (f.properties?.id ?? i);
      const nm = st.nameField ? cleanName(f.properties?.[st.nameField]) : `Polígono ${i+1}`;
      const bb = (window.turf && turf.bbox) ? turf.bbox(f) : BBOX_PRESETS.solola; // [w,s,e,n]
      items.push({ id: String(id), name: nm, feature: f, bbox: bb, area_m2: (window.turf && turf.area) ? turf.area(f) : null });
    }
    items.sort((a,b) => a.name.localeCompare(b.name, "es"));
    st.items = items;
    st.loaded = true;
  }

  function renderPolyOverlay(mode, selectedId){
    overlayGroup.clearLayers();
    const st = polyState[mode];
    if (!st?.loaded) return;

    let features = [];
    if (selectedId === "all"){
      features = st.gj.features;
    } else {
      const it = st.items.find(x => x.id === selectedId);
      if (it) features = [it.feature];
    }
    if (!features.length) return;

    L.geoJSON({ type:"FeatureCollection", features }, {
      style: { color:"#ff7a45", weight:2, opacity:0.85, fillColor:"#ffb703", fillOpacity:0.08 }
    }).addTo(overlayGroup);
  }

  function populatePolySelect(mode){
    const st = polyState[mode];
    const src = LAYER_SOURCES[mode];

    $("polyLabel").textContent = `Selecciona ${src.label}`;
    $("polyHint").textContent = `Campo etiqueta: ${st.nameField || "auto"} · Polígonos: ${st.items.length}`;

    const sel = $("polySelect");
    sel.innerHTML = "";

    const optAll = document.createElement("option");
    optAll.value = "all";
    optAll.textContent = `Todos (${st.items.length})`;
    sel.appendChild(optAll);

    for (const it of st.items){
      const opt = document.createElement("option");
      opt.value = it.id;
      opt.textContent = it.name;
      sel.appendChild(opt);
    }
    sel.value = "all";
  }

  function inBBox(lon, lat, bb){
    return (lon >= bb[0] && lon <= bb[2] && lat >= bb[1] && lat <= bb[3]);
  }

  function getBBoxFromUI(){
    const clipMode = $("clipMode").value;

    if (clipMode === "bbox_solola") return BBOX_PRESETS.solola;
    if (clipMode === "bbox_guatemala") return BBOX_PRESETS.guatemala;

    if (clipMode === "bbox_map"){
      const b = map.getBounds();
      return [b.getWest(), b.getSouth(), b.getEast(), b.getNorth()];
    }
    if (clipMode === "bbox_manual"){
      const w = Number($("w").value), s = Number($("s").value), e = Number($("e").value), n = Number($("n").value);
      if (![w,s,e,n].every(Number.isFinite) || e <= w || n <= s) return null;
      return [w,s,e,n];
    }
    if (["muni","micro","ap"].includes(clipMode)){
      const st = polyState[clipMode];
      if (!st?.loaded) return BBOX_PRESETS.solola;
      const selectedId = $("polySelect").value || "all";
      if (selectedId === "all") return (window.turf && turf.bbox) ? turf.bbox(st.gj) : BBOX_PRESETS.solola;
      const it = st.items.find(x => x.id === selectedId);
      return it ? it.bbox : BBOX_PRESETS.solola;
    }
    return BBOX_PRESETS.solola;
  }

  function fitToBBox(arr){
    const b = L.latLngBounds([arr[1], arr[0]], [arr[3], arr[2]]);
    map.fitBounds(b.pad(0.06));
  }

  function computeClipAreaKm2(){
    const clipMode = $("clipMode").value;

    // BBOX
    if (!["muni","micro","ap"].includes(clipMode)){
      const bb = getBBoxFromUI();
      if (!bb || !(window.turf && turf.bboxPolygon && turf.area)) return null;
      const poly = turf.bboxPolygon(bb);
      return turf.area(poly) / 1e6;
    }

    // Polígono(s)
    const st = polyState[clipMode];
    if (!st?.loaded) return null;

    const selectedId = $("polySelect").value || "all";
    if (selectedId !== "all"){
      const it = st.items.find(x => x.id === selectedId);
      if (it?.area_m2 != null) return it.area_m2 / 1e6;
      if (window.turf && turf.area) return turf.area(it.feature) / 1e6;
      return null;
    }

    // Suma de áreas (aprox, sin corrección por solapes)
    let sum = 0;
    for (const it of st.items){
      const a = it.area_m2 != null ? it.area_m2 : (window.turf && turf.area ? turf.area(it.feature) : 0);
      sum += a || 0;
    }
    return sum ? (sum / 1e6) : null;
  }

  function pointFilterByPolygon(rows){
    const clipMode = $("clipMode").value;
    if (!["muni","micro","ap"].includes(clipMode)) {
      return rows.map(r => ({...r, zone_type: "BBOX", zone_name: "—"}));
    }
    const st = polyState[clipMode];
    if (!st?.loaded || !(window.turf && turf.booleanPointInPolygon)){
      return rows.map(r => ({...r, zone_type: "SIG", zone_name: "—"}));
    }

    const selectedId = $("polySelect").value || "all";
    const polys = (selectedId === "all") ? st.items : st.items.filter(x => x.id === selectedId);
    const zoneType = LAYER_SOURCES[clipMode].label;

    const out = [];
    for (const r of rows){
      if (!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) continue;

      // bbox prefilter
      let matched = null;
      for (const it of polys){
        if (!inBBox(r.lon, r.lat, it.bbox)) continue;
        const pt = turf.point([r.lon, r.lat]);
        if (turf.booleanPointInPolygon(pt, it.feature)){
          matched = it;
          break;
        }
      }
      if (matched) out.push({ ...r, zone_type: zoneType, zone_name: matched.name });
    }
    return out;
  }

  // ======================
  // DATA/UI
  // ======================
  let lastData = [];
  let markerById = new Map();

  let chartDaily = null;
  let chartSensors = null;
  let chartRipley = null;
  let chartVariogram = null;
  let chartNN = null;

  function updateMap(rows){
    clusters.clearLayers();
    markerById.clear();
    if (!rows?.length) return;

    for (const r of rows){
      const col = confColor(r.confidence);
      const mk = L.marker([r.lat, r.lon], { icon: markerIcon(col) });

      const zone = r.zone_name && r.zone_name !== "—" ? `<div><b>${r.zone_type}:</b> ${r.zone_name}</div>` : "";
      mk.bindPopup(`
        <div style="font-family:system-ui; font-size:12px; line-height:1.35">
          <div><b>${r.source}</b></div>
          ${zone}
          <div>UTC: ${r.datetime_utc || (r.acq_date + " " + r.acq_time)}</div>
          <div>Conf: ${r.confidence || "—"} · FRP: ${r.frp ?? "—"} MW</div>
          <div>Sat: ${r.satellite || "—"} · Inst: ${r.instrument || "—"}</div>
        </div>
      `);

      markerById.set(r.id, mk);
      clusters.addLayer(mk);
    }
  }

  function buildTable(rows){
    const tbody = $("tbl").querySelector("tbody");
    tbody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows){
      const tr = document.createElement("tr");
      tr.dataset.id = r.id;
      tr.innerHTML = `
        <td>${r.datetime_utc || "—"}</td>
        <td>${r.zone_name || "—"}</td>
        <td>${r.source || "—"}</td>
        <td>${r.confidence || "—"}</td>
        <td>${Number.isFinite(r.lat) ? r.lat.toFixed(5) : "—"}</td>
        <td>${Number.isFinite(r.lon) ? r.lon.toFixed(5) : "—"}</td>
        <td>${r.frp ?? "—"}</td>
      `;
      frag.appendChild(tr);
    }
    tbody.appendChild(frag);

    tbody.querySelectorAll("tr").forEach(tr => {
      tr.addEventListener("click", () => {
        const mk = markerById.get(tr.dataset.id);
        if (!mk) return;
        map.setView(mk.getLatLng(), Math.max(map.getZoom(), 13));
        mk.openPopup();
      });
    });
  }

  function applyFilter(){
    const q = $("q").value.trim().toLowerCase();
    const rows = $("tbl").querySelectorAll("tbody tr");
    let shown = 0;
    rows.forEach(tr => {
      const ok = !q || tr.textContent.toLowerCase().includes(q);
      tr.style.display = ok ? "" : "none";
      if (ok) shown++;
    });
    $("tableNote").textContent = `Mostrando ${shown} / ${lastData.length} filas (filtro local).`;
  }

  function updateKPIs(rawPayload, rows){
    const total = rows.length;
    const hi = rows.reduce((acc, r) => acc + (confClass(r.confidence) === "high" ? 1 : 0), 0);
    const frpSum = rows.reduce((acc, r) => acc + (Number.isFinite(r.frp) ? r.frp : 0), 0);

    $("k_total").textContent = fmt(total);
    $("k_high").textContent = fmt(hi);
    $("k_frp").textContent = fmt(frpSum, 3);
    $("k_last").textContent = rawPayload?.summary?.last_detection_utc || "—";
  }

  // ======================
  // CHARTS + GEOESTATS
  // ======================
  function linearRegression(xs, ys){
    const n = xs.length;
    if (n < 2) return { a: 0, b: ys[0] ?? 0, r2: 0 };
    const meanX = xs.reduce((s,v)=>s+v,0)/n;
    const meanY = ys.reduce((s,v)=>s+v,0)/n;
    let num = 0, den = 0;
    for (let i=0;i<n;i++){
      num += (xs[i]-meanX)*(ys[i]-meanY);
      den += (xs[i]-meanX)*(xs[i]-meanX);
    }
    const a = den === 0 ? 0 : num/den;
    const b = meanY - a*meanX;

    let ssTot = 0, ssRes = 0;
    for (let i=0;i<n;i++){
      const yHat = a*xs[i] + b;
      ssTot += (ys[i]-meanY)**2;
      ssRes += (ys[i]-yHat)**2;
    }
    const r2 = ssTot === 0 ? 0 : 1 - (ssRes/ssTot);
    return { a, b, r2 };
  }

  function buildDailySeries(rows){
    const byDate = new Map();
    const byDateFrp = new Map();
    for (const r of rows){
      const d = r.acq_date || (r.datetime_utc ? r.datetime_utc.slice(0,10) : null);
      if (!d) continue;
      byDate.set(d, (byDate.get(d) || 0) + 1);
      byDateFrp.set(d, (byDateFrp.get(d) || 0) + (Number.isFinite(r.frp) ? r.frp : 0));
    }
    const dates = Array.from(byDate.keys()).sort();
    const counts = dates.map(d => byDate.get(d) || 0);
    const frps = dates.map(d => +(byDateFrp.get(d) || 0).toFixed(3));
    return { dates, counts, frps };
  }

  function sampleRows(rows, maxN){
    if (rows.length <= maxN) return rows;
    // muestreo aleatorio simple
    const copy = rows.slice();
    for (let i = copy.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy.slice(0, maxN);
  }

  function kmDistance(a, b){
    // turf.distance usa Haversine
    return turf.distance(turf.point([a.lon, a.lat]), turf.point([b.lon, b.lat]), { units: "kilometers" });
  }

  function computeNearestNeighborStats(points, areaKm2){
    // points: [{lat,lon,frp?}] sample
    const n = points.length;
    if (n < 2 || !areaKm2 || areaKm2 <= 0) return null;

    const nn = [];
    for (let i=0;i<n;i++){
      let best = Infinity;
      for (let j=0;j<n;j++){
        if (i===j) continue;
        const d = kmDistance(points[i], points[j]);
        if (d < best) best = d;
      }
      if (Number.isFinite(best)) nn.push(best);
    }

    const rObs = nn.reduce((a,b)=>a+b,0)/nn.length;
    const lam = n / areaKm2; // puntos/km2
    const rExp = 0.5 / Math.sqrt(lam);

    // Clark–Evans SE (aprox) para CSR
    const se = 0.26136 / Math.sqrt(n * lam);
    const z = se > 0 ? (rObs - rExp) / se : null;

    return { n, areaKm2, lam, rObs, rExp, nni: rObs/rExp, se, z, nn };
  }

  function computeRipleyL(points, areaKm2, rMaxKm=20, bins=25){
    const n = points.length;
    if (n < 2 || !areaKm2 || areaKm2 <= 0) return null;

    const dr = rMaxKm / bins;
    const hist = new Array(bins).fill(0); // conteo de pares por bin

    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        const d = kmDistance(points[i], points[j]);
        if (d <= rMaxKm){
          const k = Math.min(bins-1, Math.floor(d / dr));
          hist[k] += 1;
        }
      }
    }

    // acumulado de pares <= r
    const cum = [];
    let s = 0;
    for (let k=0;k<bins;k++){
      s += hist[k];
      cum.push(s);
    }

    const rs = [];
    const L = [];
    for (let k=0;k<bins;k++){
      const r = (k+1) * dr;
      rs.push(+r.toFixed(3));
      const pairLE = cum[k]; // unordered pairs
      // K(r) = (A/(n(n-1))) * 2 * pairLE
      const K = (areaKm2 / (n*(n-1))) * (2 * pairLE);
      const Lr = Math.sqrt(K / Math.PI) - r;
      L.push(+Lr.toFixed(4));
    }

    return { rs, L };
  }

  function computeVariogram(points, rMaxKm=20, bins=20){
    // z = FRP
    const usable = points.filter(p => Number.isFinite(p.frp));
    const n = usable.length;
    if (n < 3) return null;

    const dr = rMaxKm / bins;
    const count = new Array(bins).fill(0);
    const sumSq = new Array(bins).fill(0);

    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        const d = kmDistance(usable[i], usable[j]);
        if (d <= rMaxKm){
          const k = Math.min(bins-1, Math.floor(d / dr));
          const diff = usable[i].frp - usable[j].frp;
          sumSq[k] += diff*diff;
          count[k] += 1;
        }
      }
    }

    const hs = [];
    const gamma = [];
    for (let k=0;k<bins;k++){
      const h = (k+0.5)*dr;
      hs.push(+h.toFixed(3));
      if (count[k] > 0){
        gamma.push(+((0.5 * (sumSq[k]/count[k]))).toFixed(4));
      } else {
        gamma.push(null);
      }
    }

    return { hs, gamma, count };
  }

  function updateChartsAndStats(rows){
    // 1) temporal + tendencia
    const { dates, counts, frps } = buildDailySeries(rows);
    const xs = dates.map((_,i)=>i);
    const reg = linearRegression(xs, counts);
    const trend = xs.map(x => reg.a*x + reg.b);

    const eq = `y = ${reg.a.toFixed(3)}x + ${reg.b.toFixed(3)} · R² = ${Math.max(0, Math.min(1, reg.r2)).toFixed(3)}`;
    $("trendNote").textContent = `Tendencia (detecciones/día, OLS): ${eq}`;

    const ctx1 = $("chartDaily").getContext("2d");
    if (chartDaily) chartDaily.destroy();
    chartDaily = new Chart(ctx1, {
      type: "line",
      data: {
        labels: dates,
        datasets: [
          { label: "Detecciones/día", data: counts, tension: 0.25 },
          { label: "Tendencia (OLS)", data: trend, tension: 0, borderDash: [6,6], pointRadius: 0 },
          { label: "FRP/día (MW)", data: frps, yAxisID: "y2", tension: 0.25 }
        ]
      },
      options: {
        responsive: true,
        plugins: { legend: { position: "bottom" } },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: "Detecciones" } },
          y2: { beginAtZero: true, position: "right", grid: { drawOnChartArea: false }, title: { display: true, text: "FRP (MW)" } }
        }
      }
    });

    // 2) sensores
    const bySensor = {};
    for (const r of rows){
      const s = r.source || "—";
      bySensor[s] = (bySensor[s] || 0) + 1;
    }
    const sensors = Object.keys(bySensor).sort();
    const vals = sensors.map(s => bySensor[s]);
    const total = vals.reduce((a,b)=>a+b,0) || 1;
    const perc = vals.map(v => +(100*v/total).toFixed(2));

    const ctx2 = $("chartSensors").getContext("2d");
    if (chartSensors) chartSensors.destroy();
    chartSensors = new Chart(ctx2, {
      type: "bar",
      data: { labels: sensors, datasets: [{ label:"Detecciones", data: vals }, { label:"%", data: perc }] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });

    // 3) Geoestadística (muestreo para O(n^2))
    const areaKm2 = computeClipAreaKm2();
    const maxN = 2200; // seguridad de rendimiento
    const pts = sampleRows(rows.map(r => ({ lat:r.lat, lon:r.lon, frp: (Number.isFinite(r.frp) ? r.frp : null) })), maxN);

    let note = "";
    if (!areaKm2 || !(window.turf && turf.distance)){
      note = "Área A no disponible para el recorte; geoestadística no calculada.";
      $("geoStatsNote").textContent = note;
      return;
    }
    if (pts.length < 10){
      note = "Muy pocos puntos para análisis geoestadístico (n < 10).";
      $("geoStatsNote").textContent = note;
      return;
    }

    const nni = computeNearestNeighborStats(pts, areaKm2);
    if (!nni){
      $("geoStatsNote").textContent = "No se pudo calcular NNI.";
      return;
    }

    // Clasificación rápida
    const pattern = (nni.nni < 1) ? "agrupamiento (cluster)" : (nni.nni > 1 ? "dispersión/regularidad" : "aleatorio ~CSR");
    const ztxt = (nni.z == null) ? "—" : nni.z.toFixed(2);
    const lamTxt = nni.lam.toFixed(4);

    note =
      `A≈${areaKm2.toFixed(2)} km² · n=${pts.length} (muestra; total=${rows.length}) · λ=${lamTxt} pts/km² · ` +
      `r̄obs=${nni.rObs.toFixed(3)} km · r̄exp(CSR)=${nni.rExp.toFixed(3)} km · NNI=${nni.nni.toFixed(3)} · z≈${ztxt} → ${pattern}.`;
    $("geoStatsNote").textContent = note;

    // NN histogram chart
    const nn = nni.nn.slice().sort((a,b)=>a-b);
    const maxD = Math.min(10, nn[Math.floor(nn.length*0.98)] || 10); // cap 10 km para hist
    const bins = 20;
    const step = maxD / bins;
    const h = new Array(bins).fill(0);
    for (const d of nn){
      if (d > maxD) continue;
      const k = Math.min(bins-1, Math.floor(d/step));
      h[k] += 1;
    }
    const xh = h.map((_,k)=>+( (k+0.5)*step ).toFixed(3));
    const ctxNN = $("chartNN").getContext("2d");
    if (chartNN) chartNN.destroy();
    chartNN = new Chart(ctxNN, {
      type: "bar",
      data: {
        labels: xh.map(v=>String(v)),
        datasets: [{ label: "Distribución dist. vecino más cercano (km)", data: h }]
      },
      options: {
        responsive:true,
        plugins:{ legend:{ position:"bottom" } },
        scales:{ y:{ beginAtZero:true }, x:{ title:{ display:true, text:"km" } } }
      }
    });

    // Ripley L
    const rip = computeRipleyL(pts, areaKm2, 20, 25);
    const ctxR = $("chartRipley").getContext("2d");
    if (chartRipley) chartRipley.destroy();
    chartRipley = new Chart(ctxR, {
      type: "line",
      data: {
        labels: rip ? rip.rs.map(r=>String(r)) : [],
        datasets: rip ? [
          { label: "L(r) = √(K/π) − r (km)", data: rip.L, tension: 0.15 }
        ] : []
      },
      options: {
        responsive:true,
        plugins:{ legend:{ position:"bottom" } },
        scales:{
          y:{ title:{ display:true, text:"L(r) (km)" } },
          x:{ title:{ display:true, text:"r (km)" } }
        }
      }
    });

    // Variogram FRP
    const vario = computeVariogram(pts, 20, 20);
    const ctxV = $("chartVariogram").getContext("2d");
    if (chartVariogram) chartVariogram.destroy();
    chartVariogram = new Chart(ctxV, {
      type: "line",
      data: {
        labels: vario ? vario.hs.map(v=>String(v)) : [],
        datasets: vario ? [
          { label: "Variograma experimental γ(h) de FRP", data: vario.gamma, tension: 0.1 }
        ] : []
      },
      options: {
        responsive:true,
        plugins:{ legend:{ position:"bottom" } },
        scales:{
          y:{ title:{ display:true, text:"γ(h)" } },
          x:{ title:{ display:true, text:"h (km)" } }
        }
      }
    });
  }

  // ======================
  // EXPORTS
  // ======================
  function exportCSV(){
    if (!lastData.length) return;
    const cols = ["datetime_utc","zone_type","zone_name","source","confidence","lat","lon","frp","satellite","instrument","acq_date","acq_time"];
    const lines = [cols.join(",")];
    for (const r of lastData){
      const row = cols.map(c => {
        const v = (r[c] ?? "").toString();
        if (v.includes(",") || v.includes('"') || v.includes("\n")) return `"${v.replaceAll('"','""')}"`;
        return v;
      });
      lines.push(row.join(","));
    }
    const blob = new Blob([lines.join("\n")], { type:"text/csv;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "firs_hotspots_filtrados.csv";
    document.body.appendChild(a);
    a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }

  function exportExcel(){
    if (!lastData.length) return;
    if (!window.XLSX){
      setStatus("No se cargó XLSX (SheetJS). Usa CSV por ahora.");
      return;
    }
    const rows = lastData.map(r => ({
      datetime_utc: r.datetime_utc || "",
      zone_type: r.zone_type || "",
      zone_name: r.zone_name || "",
      source: r.source || "",
      confidence: r.confidence || "",
      lat: r.lat,
      lon: r.lon,
      frp: r.frp,
      satellite: r.satellite || "",
      instrument: r.instrument || "",
      acq_date: r.acq_date || "",
      acq_time: r.acq_time || "",
    }));
    const ws = XLSX.utils.json_to_sheet(rows);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Hotspots");
    XLSX.writeFile(wb, "firs_hotspots_filtrados.xlsx");
  }

  function exportGeoJSON(){
    if (!lastData.length) return;
    const fc = { type:"FeatureCollection", features: lastData.map(r => ({
      type:"Feature",
      geometry:{ type:"Point", coordinates:[r.lon, r.lat] },
      properties:{ ...r }
    }))};
    const blob = new Blob([JSON.stringify(fc, null, 2)], { type:"application/geo+json;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "firs_hotspots_filtrados.geojson";
    document.body.appendChild(a);
    a.click(); a.remove(); URL.revokeObjectURL(a.href);
  }

  // ======================
  // HEALTH + MAIN RUN
  // ======================
  let autoTimer = null;

  async function checkHealth(){
    const dot = $("dot");
    try{
      const r = await fetch(`${PROXY_BASE}/health`);
      const j = await r.json();
      $("pillText").textContent = j.ok ? "Proxy: OK" : "Proxy: error";
      if (dot) dot.style.background = j.ok ? "#2fd08f" : "#f0b24d";
    }catch(e){
      $("pillText").textContent = "Proxy: no responde";
      if (dot) dot.style.background = "#f0b24d";
    }
  }

  async function run(){
    const days = Number($("days").value);
    const sensors = getSensors();
    const bboxArr = getBBoxFromUI();
    const limit = Number($("limit").value);
    const conf = $("conf").value;

    if (!sensors.length) return setStatus("Selecciona al menos un sensor.");
    if (!bboxArr) return setStatus("BBOX inválido. Revisa el modo seleccionado.");

    const bbox = bboxStr(bboxArr);
    const url = `${PROXY_BASE}/api/firms?bbox=${encodeURIComponent(bbox)}&days=${days}&sensors=${encodeURIComponent(sensors.join(","))}&limit=${limit}`;

    setStatus(`Consultando FIRMS...\n${url}`);

    const t0 = performance.now();
    const r = await fetch(url);
    const j = await r.json();
    const ms = Math.round(performance.now() - t0);

    if (!r.ok && !j.ok){
      const extra = (j?.error && String(j.error).includes("1..30"))
        ? "\n\nNota: para 60/90 días, sube MAX_DAYS a 90 en el Worker y redeploy."
        : "";
      return setStatus(`Error (${r.status}).\n${j.error || "Sin detalle"}${extra}`);
    }

    setStatus(`OK. Total (dedupe): ${j.total}. Filas devueltas: ${j.rows.length}. (${ms} ms)`);

    let rows = (j.rows || []).filter(rr => conf === "all" ? true : confClass(rr.confidence) === conf);
    rows = pointFilterByPolygon(rows);
    rows.sort((a,b) => (a.datetime_utc || "") < (b.datetime_utc || "") ? 1 : -1);

    lastData = rows;

    updateMap(lastData);
    buildTable(lastData);
    updateKPIs(j, lastData);
    updateChartsAndStats(lastData);
    applyFilter();

    $("lastRun").textContent = `Última actualización: ${new Date().toLocaleString("es-GT")}`;

    const clipMode = $("clipMode").value;
    if (["muni","micro","ap"].includes(clipMode)){
      renderPolyOverlay(clipMode, $("polySelect").value || "all");
    } else {
      overlayGroup.clearLayers();
    }

    // re-render map after layout changes (mobile)
    setTimeout(() => map.invalidateSize(), 120);
  }

  function setupAuto(){
    if (autoTimer) clearInterval(autoTimer);
    if ($("auto").checked) autoTimer = setInterval(run, 10 * 60 * 1000);
  }

  async function updateClipUI(){
    const mode = $("clipMode").value;

    $("manualBBox").style.display = (mode === "bbox_manual") ? "block" : "none";
    const isPoly = ["muni","micro","ap"].includes(mode);
    $("polyPick").style.display = isPoly ? "block" : "none";

    if (!isPoly){
      overlayGroup.clearLayers();
      return;
    }

    try{
      await ensurePolyLoaded(mode);
      populatePolySelect(mode);
      renderPolyOverlay(mode, $("polySelect").value || "all");
      const bb = getBBoxFromUI();
      if (bb) fitToBBox(bb);
    }catch(err){
      setStatus(`Error cargando capa SIG.\n${String(err)}`);
    }
  }

  // ======================
  // EVENTS
  // ======================
  $("clipMode").addEventListener("change", () => updateClipUI());
  $("polySelect").addEventListener("change", () => {
    const mode = $("clipMode").value;
    if (["muni","micro","ap"].includes(mode)){
      renderPolyOverlay(mode, $("polySelect").value || "all");
    }
  });

  $("btnRun").addEventListener("click", run);
  $("btnFit").addEventListener("click", () => {
    const bb = getBBoxFromUI();
    if (!bb) return setStatus("No hay BBOX válido para ajustar.");
    fitToBBox(bb);
    setStatus("Mapa ajustado al recorte.");
  });

  $("btnCSV").addEventListener("click", exportCSV);
  $("btnExcel").addEventListener("click", exportExcel);
  $("btnGeoJSON").addEventListener("click", exportGeoJSON);

  $("btnClear").addEventListener("click", () => { $("q").value=""; applyFilter(); });
  $("q").addEventListener("input", applyFilter);
  $("auto").addEventListener("change", setupAuto);

  // Init
  (async function init(){
    fitToBBox(BBOX_PRESETS.solola);
    await checkHealth();
    setupAuto();
    await updateClipUI();
    await run();
  })();
})();
</script>
</body>
</html>
