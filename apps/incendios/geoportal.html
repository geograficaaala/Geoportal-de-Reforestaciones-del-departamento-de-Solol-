<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Incendios — Dashboard FIRMS (NRT) · Sololá</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js" crossorigin=""></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- SheetJS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

  <!-- KaTeX -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>

  <style>
    :root{
      /* Verde / amarillo */
      --bg0:#f6fff7;
      --bg1:#fffdf1;
      --card:rgba(255,255,255,.92);
      --card2:rgba(255,255,255,.98);

      --ink:#1a2a1e;
      --muted:#4b6354;
      --stroke:rgba(18,42,28,.12);

      --green:#1f9d55;
      --lime:#a3e635;
      --amber:#fbbf24;
      --gold:#f59e0b;

      --hi:#16a34a;
      --nom:#f59e0b;
      --low:#94a3b8;

      --shadow: 0 14px 40px rgba(20,60,30,.12);
      --shadow-sm: 0 10px 22px rgba(20,60,30,.10);
      --radius: 18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      color:var(--ink);
      background:
        radial-gradient(900px 560px at 0% 0%, rgba(31,157,85,.16), transparent 62%),
        radial-gradient(900px 560px at 100% 0%, rgba(245,158,11,.14), transparent 62%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }

    header{
      position: sticky;
      top: 0;
      z-index: 60;
      backdrop-filter: blur(10px);
      background: rgba(255,255,255,.78);
      border-bottom: 1px solid var(--stroke);
    }
    .header-wrap{
      padding: 10px 14px;
      display:flex;
      gap:12px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .title{ display:flex; flex-direction:column; gap:2px; min-width: 260px; }
    .title h1{ margin:0; font-size: 15px; letter-spacing:.2px; }
    .title .sub{ font-size:12px; color:var(--muted); }

    .brand-logos{
      display:flex;
      gap:10px;
      align-items:center;
    }
    .brand-logos img{
      height: 34px;
      width: auto;
      object-fit: contain;
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 10px;
      padding: 3px 6px;
      box-shadow: var(--shadow-sm);
    }

    .chips{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .chip{
      display:inline-flex; align-items:center; gap:8px;
      padding:8px 10px;
      background: var(--card2);
      border:1px solid var(--stroke);
      border-radius: 999px;
      box-shadow: var(--shadow-sm);
      font-size:12px;
      color: var(--muted);
      white-space:nowrap;
    }
    .dot{
      width:10px; height:10px; border-radius:50%;
      background: #2fd08f;
      box-shadow: 0 0 0 4px rgba(47,208,143,.18);
    }

    main{
      display:grid;
      grid-template-columns: 400px 1fr;
      gap:14px;
      padding: 14px 14px 18px;
      align-items:stretch;
    }

    .panel{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-width:0;
    }
    .panel h2{
      margin:0;
      padding:12px 14px;
      font-size:13px;
      color:#183522;
      border-bottom: 1px solid rgba(0,0,0,.06);
      background: linear-gradient(180deg, rgba(255,255,255,.92), rgba(255,255,255,.82));
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .panel h2 small{ font-weight:600; color: var(--muted); }
    .panel .content{ padding: 12px 14px 14px; }

    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    label{ display:block; font-size:12px; color:var(--muted); margin-bottom:6px; }
    select, input[type="text"], input[type="number"]{
      width:100%;
      padding:10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,.14);
      background: #fff;
      outline:none;
    }
    input[type="checkbox"]{ transform: translateY(1px); }

    .checks{
      display:grid; gap:8px;
      padding:10px;
      background:#fff;
      border:1px solid rgba(0,0,0,.14);
      border-radius:12px;
    }
    .checks .row{ display:flex; gap:8px; align-items:flex-start; font-size:12.5px; color:#183522; }
    .checks small{ display:block; color:var(--muted); margin-top:2px; }

    .btns{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
    button{
      border:none; cursor:pointer;
      padding:10px 12px;
      border-radius: 12px;
      font-weight:850; font-size:12.5px;
    }
    .btn-primary{ background: linear-gradient(135deg, var(--green), var(--amber)); color:#fff; }
    .btn-ghost{ background:#fff; border:1px solid rgba(0,0,0,.14); color:#153220; }

    .status{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background:#fff;
      border:1px dashed rgba(31,157,85,.35);
      color: var(--muted);
      font-size:12px;
      line-height:1.35;
      white-space:pre-wrap;
    }

    .notes{
      margin-top:10px;
      padding:10px;
      border-radius:12px;
      background: linear-gradient(180deg, rgba(255,255,255,.96), rgba(255,255,255,.86));
      border:1px solid rgba(0,0,0,.10);
      color: var(--muted);
      font-size:12px;
      line-height:1.45;
    }
    .notes ul{ margin:8px 0 0; padding-left: 18px; }
    .notes li{ margin:6px 0; }

    .right{
      display:grid;
      grid-template-rows: auto auto auto auto auto;
      gap:14px;
      min-width:0;
    }

    .mapWrap{ padding:12px 14px 14px; position:relative; }
    #map{
      height: 460px;
      min-height: 460px;
      border-radius: var(--radius);
      background: #f2fbf4;
      outline: 1px solid rgba(0,0,0,.06);
    }
    .mapError{
      display:none;
      position:absolute;
      inset: 16px 18px auto 18px;
      background: rgba(255,255,255,.96);
      border: 1px solid rgba(0,0,0,.14);
      border-radius: 14px;
      padding: 10px 12px;
      box-shadow: var(--shadow-sm);
      color: #7b3b1f;
      font-size: 12px;
      line-height: 1.35;
    }
    .mapError code{ background:#f3f3f3; padding:2px 6px; border-radius:8px; }

    .legend{
      display:flex; gap:10px; flex-wrap:wrap;
      padding: 0 14px 14px;
      font-size:12px; color:var(--muted);
    }
    .lg{
      display:flex; align-items:center; gap:6px;
      padding:6px 8px;
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:999px;
    }
    .sw{ width:10px; height:10px; border-radius:50%; }

    .kpis{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
      padding: 12px 14px 14px;
    }
    .kpi{
      border:1px solid rgba(0,0,0,.10);
      border-radius: 14px;
      padding:10px;
      background:#fff;
      min-width:0;
    }
    .kpi .k{ font-size:11px; color:var(--muted); }
    .kpi .v{ font-size:16px; font-weight:950; margin-top:4px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .chartsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .chartCard{
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:14px;
      padding:10px;
      min-width:0;
    }
    .chartTitle{
      font-size:12px;
      font-weight:850;
      color:#183522;
      margin-bottom:6px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .chartEq{
      margin-top:6px;
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
      overflow:auto;
    }

    .geoKpiGrid{
      display:grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:10px;
      padding: 12px 14px 14px;
    }
    .geoKpi{
      background:#fff;
      border:1px solid rgba(0,0,0,.10);
      border-radius:14px;
      padding:10px;
      min-width:0;
    }
    .geoKpi .k{ font-size:11px; color:var(--muted); }
    .geoKpi .v{ font-size:15px; font-weight:950; margin-top:4px; }
    .geoKpi .s{ font-size:11px; color:var(--muted); margin-top:4px; line-height:1.25; }

    .geoInterpret{
      margin: 0 14px 14px;
      padding: 12px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,.88);
      border: 1px dashed rgba(0,0,0,.12);
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }

    .eq{
      padding: 10px 14px 14px;
      border-top: 1px dashed rgba(0,0,0,.10);
      background: rgba(255,255,255,.7);
    }
    .eq .eq-title{ font-size:12px; color:var(--muted); font-weight:850; margin-bottom:8px; }
    .eq .eq-box{
      border: 1px solid rgba(0,0,0,.08);
      border-radius: 14px;
      padding: 10px 12px;
      background:#fff;
      overflow:auto;
    }

    .filtersRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .filtersRow input{ flex:1; min-width: 220px; }

    .tableWrap{
      overflow:auto;
      max-height: 420px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,.10);
      background:#fff;
      margin-top:10px;
    }
    table{ width:100%; border-collapse: collapse; font-size:12px; }
    thead th{
      position:sticky; top:0; z-index:1;
      background:#f0fff2;
      border-bottom:1px solid rgba(0,0,0,.10);
      text-align:left;
      padding:10px 8px;
      color:#183522;
      white-space:nowrap;
    }
    tbody td{
      border-bottom:1px solid rgba(0,0,0,.06);
      padding:8px 8px;
      color:#153220;
      vertical-align:top;
      white-space:nowrap;
    }
    tbody tr:hover{ background:#f6fff7; cursor:pointer; }

    .hint{ font-size:12px; color:var(--muted); line-height:1.35; margin-top:8px; }

    .hotspot{
      width:14px; height:14px;
      border-radius:50%;
      border:2px solid rgba(255,255,255,.92);
      box-shadow: 0 6px 18px rgba(0,0,0,.18);
    }

    footer{
      padding: 10px 14px 24px;
      color: var(--muted);
      font-size: 12px;
    }
    .footer-box{
      background: var(--card);
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 12px 14px;
    }
    .footer-logos{
      display:flex;
      flex-wrap:wrap;
      gap:14px;
      align-items:center;
      justify-content:center;
      margin-top:10px;
    }
    .footer-logos img{
      max-height: 44px;
      width: auto;
      object-fit: contain;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,.06));
      background: rgba(255,255,255,.94);
      border-radius: 10px;
      padding: 4px 6px;
    }

    @media (max-width: 1120px){
      main{ grid-template-columns: 1fr; }
      .kpis{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .geoKpiGrid{ grid-template-columns: repeat(2, minmax(0,1fr)); }
      .chartsGrid{ grid-template-columns: 1fr; }
      #map{ height: 420px; min-height: 420px; }
    }
  </style>
</head>

<body>
  <header>
    <div class="header-wrap">
      <div class="brand-logos" aria-label="Logos institucionales">
        <img src="../../BOSQUE.png" alt="Eje de Bosques">
        <img src="../../CODEMA%20%282%29.png" alt="CODEMA Sololá">
      </div>
      <div class="title">
        <h1>Incendios — Anomalías térmicas (FIRMS NRT)</h1>
        <div class="sub">Recorte por capas SIG (Municipios / Microcuencas / Áreas protegidas) · UTC</div>
      </div>

      <div class="chips">
        <div class="chip" title="Estado del proxy">
          <span class="dot" id="dot"></span>
          <span id="pillText">Proxy: sin verificar</span>
        </div>
        <div class="chip" title="Auto actualización">
          <input id="auto" type="checkbox" checked />
          <label for="auto" style="margin:0; cursor:pointer;">Auto (10 min)</label>
        </div>
        <div class="chip" id="lastRun">Última actualización: —</div>
      </div>
    </div>
  </header>

  <main>
    <!-- LEFT: filtros -->
    <section class="panel">
      <h2>Consulta y recorte <small>(solo capas)</small></h2>
      <div class="content">
        <div class="grid2">
          <div>
            <label for="days">Período</label>
            <select id="days">
              <option value="1">24 horas (1 día)</option>
              <option value="3" selected>72 horas (3 días)</option>
              <option value="7">7 días</option>
              <option value="30">30 días</option>
              <option value="60">60 días</option>
              <option value="90">90 días</option>
            </select>
          </div>
          <div>
            <label for="clipMode">Capa de recorte</label>
            <select id="clipMode">
              <option value="muni" selected>Municipios (Sololá)</option>
              <option value="micro">Microcuencas (Atitlán)</option>
              <option value="ap">Áreas protegidas</option>
            </select>
          </div>
        </div>

        <div style="height:10px"></div>

        <div>
          <label id="polyLabel">Elemento de recorte</label>
          <select id="polySelect"></select>
          <div class="hint" id="polyHint"></div>
        </div>

        <div style="height:10px"></div>

        <label>Sensores (Near Real-Time)</label>
        <div class="checks">
          <div class="row">
            <input type="checkbox" id="s_snpp" checked>
            <div><b>VIIRS Suomi-NPP</b><small>VIIRS_SNPP_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_n20" checked>
            <div><b>VIIRS NOAA-20 (JPSS-1)</b><small>VIIRS_NOAA20_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_n21" checked>
            <div><b>VIIRS NOAA-21 (JPSS-2)</b><small>VIIRS_NOAA21_NRT</small></div>
          </div>
          <div class="row">
            <input type="checkbox" id="s_modis" checked>
            <div><b>MODIS (Terra/Aqua) NRT</b><small>MODIS_NRT</small></div>
          </div>
        </div>

        <div style="height:10px"></div>

        <div class="grid2">
          <div>
            <label for="conf">Confianza del algoritmo</label>
            <select id="conf">
              <option value="all" selected>Todas</option>
              <option value="high">Alta</option>
              <option value="nominal">Nominal/Media</option>
              <option value="low">Baja</option>
            </select>
          </div>
          <div>
            <label for="limit">Límite filas</label>
            <select id="limit">
              <option value="2000">2,000</option>
              <option value="10000" selected>10,000</option>
              <option value="20000">20,000</option>
              <option value="50000">50,000</option>
            </select>
          </div>
        </div>

        <div class="btns">
          <button class="btn-primary" id="btnRun">Actualizar</button>
          <button class="btn-ghost" id="btnFit">Ajustar mapa</button>
        </div>

        <div class="status" id="status">Listo.</div>

        <div class="notes">
          <b>Notas técnicas</b>
          <ul>
            <li>Hotspots (fuego activo) ≠ perímetro ni área quemada. Ubicación aproximada al píxel (VIIRS ~375 m; MODIS ~1 km).</li>
            <li>Nubosidad/humo y tiempo de paso orbital pueden ocultar focos; se recomienda verificación operativa local.</li>
            <li>FRP (MW) es potencia radiativa del fuego (indicador energético), no equivale directamente a superficie afectada.</li>
          </ul>
        </div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="right">
      <!-- 1) MAPA -->
      <section class="panel">
        <h2>Mapa <small id="mapSubtitle">—</small></h2>
        <div class="mapWrap">
          <div id="map"></div>
          <div class="mapError" id="mapError"></div>
        </div>
        <div class="legend">
          <div class="lg"><span class="sw" style="background:var(--hi)"></span> Alta</div>
          <div class="lg"><span class="sw" style="background:var(--nom)"></span> Nominal/Media</div>
          <div class="lg"><span class="sw" style="background:var(--low)"></span> Baja</div>
        </div>
      </section>

      <!-- 2) KPIs operativos -->
      <section class="panel">
        <h2>KPIs operativos <small>(recorte actual)</small></h2>
        <div class="kpis">
          <div class="kpi"><div class="k">Detecciones</div><div class="v" id="k_total">—</div></div>
          <div class="kpi"><div class="k">Alta confianza</div><div class="v" id="k_high">—</div></div>
          <div class="kpi"><div class="k">FRP total (MW)</div><div class="v" id="k_frp">—</div></div>
          <div class="kpi"><div class="k">Última detección (UTC)</div><div class="v" id="k_last">—</div></div>
        </div>
      </section>

      <!-- 3) GRÁFICAS -->
      <section class="panel">
        <h2>Gráficas <small>(recorte espacial)</small></h2>
        <div class="content">
          <div class="chartsGrid">
            <div class="chartCard">
              <div class="chartTitle">Serie temporal & tendencia (OLS)</div>
              <canvas id="chartDaily" height="150"></canvas>
              <div class="chartEq" id="eqDaily"></div>
            </div>

            <div class="chartCard">
              <div class="chartTitle">Detecciones por sensor</div>
              <canvas id="chartSensors" height="150"></canvas>
            </div>

            

            <div class="chartCard">
              <div class="chartTitle" id="zoneChartTitle">Detecciones por zona</div>
              <canvas id="chartZonesPie" height="150"></canvas>
              <div class="chartEq" id="zoneChartNote"></div>
            </div>
<div class="chartCard">
              <div class="chartTitle">Ripley \(L(r)\) + envelope CSR</div>
              <canvas id="chartRipley" height="150"></canvas>
              <div class="chartEq" id="eqRipley"></div>
            </div>

            <div class="chartCard">
              <div class="chartTitle">Variograma experimental \(\gamma(h)\) (FRP)</div>
              <canvas id="chartVariogram" height="150"></canvas>
              <div class="chartEq" id="eqVario"></div>
            </div>

            <div class="chartCard">
              <div class="chartTitle">Histograma vecino más cercano</div>
              <canvas id="chartNN" height="150"></canvas>
            </div>
          </div>
        </div>
      </section>

      <!-- 4) GEOESTADÍSTICA -->
      <section class="panel">
        <h2>Geoestadística <small>(NNI / CSR / SDE)</small></h2>
        <div class="geoKpiGrid">
          <div class="geoKpi"><div class="k">Área \(A\)</div><div class="v" id="g_area">—</div><div class="s" id="g_area_s">—</div></div>
          <div class="geoKpi"><div class="k">Muestra \(n\) / Total</div><div class="v" id="g_n">—</div><div class="s" id="g_n_s">—</div></div>
          <div class="geoKpi"><div class="k">Intensidad \(\lambda\)</div><div class="v" id="g_lambda">—</div><div class="s">\(\lambda=n/A\)</div></div>
          <div class="geoKpi"><div class="k">NNI</div><div class="v" id="g_nni">—</div><div class="s" id="g_nni_s">—</div></div>

          <div class="geoKpi"><div class="k">z / p</div><div class="v" id="g_z">—</div><div class="s" id="g_p">p: —</div></div>
          <div class="geoKpi"><div class="k">Pico \(L(r)\)</div><div class="v" id="g_lmax">—</div><div class="s" id="g_lr">—</div></div>
          <div class="geoKpi"><div class="k">CSR (Monte Carlo)</div><div class="v" id="g_mc">—</div><div class="s" id="g_mc_s">—</div></div>
          <div class="geoKpi"><div class="k">SDE / Elipse</div><div class="v" id="g_sd">—</div><div class="s" id="g_sde">—</div></div>
        </div>

        <div class="geoInterpret" id="geoInterpret">
          Interpretación: — 
        </div>

        <div class="eq">
          <div class="eq-title">Ecuaciones (render tipo “Word”)</div>
          <div class="eq-box" id="eqBox">
$$
\begin{aligned}
\bar r_{\mathrm{exp}} &= \frac{1}{2\sqrt{\lambda}}, \qquad \mathrm{NNI}=\frac{\bar r_{\mathrm{obs}}}{\bar r_{\mathrm{exp}}} \\
K(r) &= \frac{A}{n(n-1)}\sum_{i\ne j}\mathbf{1}\{d_{ij}\le r\}, \qquad L(r)=\sqrt{\frac{K(r)}{\pi}}-r \\
\gamma(h) &= \frac{1}{2}\,\mathbb{E}\left[(z(\mathbf{s})-z(\mathbf{s+h}))^2\right]
\end{aligned}
$$
          </div>
        </div>
      </section>

      <!-- 5) TABLA -->
      <section class="panel">
        <h2>Tabla de resultados <small>(descarga Excel/CSV)</small></h2>
        <div class="content">
          <div class="filtersRow">
            <input id="q" type="text" placeholder="Filtrar tabla (zona, sensor, fecha, satélite…)" />
            <button class="btn-ghost" id="btnClear">Limpiar</button>
          </div>

          <div class="btns" style="margin-top:10px">
            <button class="btn-ghost" id="btnExcel">Excel (tabla)</button>
            <button class="btn-ghost" id="btnCSV">CSV (tabla)</button>
            <button class="btn-ghost" id="btnGeoJSON">GeoJSON (puntos)</button>
          </div>

          <div class="tableWrap">
            <table id="tbl">
              <thead>
                <tr>
                  <th>UTC</th>
                  <th>Zona</th>
                  <th>Sensor</th>
                  <th>Conf.</th>
                  <th>Lat</th>
                  <th>Lon</th>
                  <th>FRP</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>

          <div class="hint" id="tableNote"></div>
        </div>
      </section>
    </section>
  </main>

  <footer>
    <div class="footer-box">
      <div style="text-align:center; font-weight:850;">Eje de Bosques · CODEMA Sololá · Instituciones participantes</div>
      <div class="footer-logos" aria-label="Logos institucionales">
        <img src="../../BOSQUE.png" alt="Eje de Bosques">
        <img src="../../CODEMA%20%282%29.png" alt="CODEMA Sololá">
        <img src="../../marn.png" alt="MARN">
        <img src="../../maga.png" alt="MAGA">
        <img src="../../inab.png" alt="INAB">
        <img src="../../conap.png" alt="CONAP">
        <img src="../../amsclae.png" alt="AMSCLAE">
        <img src="../../conred.png" alt="CONRED">
        <img src="../../cea.png" alt="CEA - UVG">
        <img src="../../aala_logo.png" alt="Amigos del Lago de Atitlán">
        <img src="../../vivamos.png" alt="Vivamos Mejor Guatemala">
        <img src="../../aires.png" alt="AIR">
      </div>
      <div style="text-align:center; margin-top:10px;">
        Fuentes: NASA FIRMS (LANCE) — Active Fire (NRT) · Turf.js · Leaflet · Chart.js · KaTeX
      </div>
    </div>
  </footer>

<script>
(() => {
  // ======================
  // CONFIG
  // ======================
  const PROXY_BASE = "https://royal-dust-e52cfirms-proxy-solola.sgeograficaaala.workers.dev";
  const LAYER_SOURCES = {
    muni:  { url: "./data/municipios_solola.geojson", label: "Municipios (Sololá)" },
    micro: { url: "./data/microcuencas_atitlan.geojson", label: "Microcuencas (Atitlán)" },
    ap:    { url: "./data/areas_protegidas.geojson", label: "Áreas protegidas" },
  };

  const $ = (id) => document.getElementById(id);
  const mapError = $("mapError");

  function showMapError(msg){
    if (!mapError) return;
    mapError.style.display = "block";
    mapError.innerHTML = msg;
  }

  window.addEventListener("error", (e) => {
    const m = (e && e.message) ? e.message : "Error desconocido";
    showMapError(`Error JavaScript: <code>${m}</code><br/>Abre DevTools → Console para ver detalles.`);
  });

  function setStatus(msg){ $("status").textContent = msg; }
  function fmt(n, d=0){
    if (n === null || n === undefined || Number.isNaN(n)) return "—";
    return new Intl.NumberFormat("es-GT",{ maximumFractionDigits:d }).format(n);
  }

  function confClass(c){
    const s = String(c ?? "").trim().toLowerCase();
    const n = Number(s);
    if (!Number.isNaN(n)){
      if (n >= 80) return "high";
      if (n >= 30) return "nominal";
      return "low";
    }
    if (["h","high"].includes(s)) return "high";
    if (["n","nominal","m","medium"].includes(s)) return "nominal";
    if (["l","low"].includes(s)) return "low";
    return "unknown";
  }

  function confColor(c){
    const css = getComputedStyle(document.documentElement);
    const k = confClass(c);
    if (k === "high") return css.getPropertyValue("--hi").trim();
    if (k === "nominal") return css.getPropertyValue("--nom").trim();
    return css.getPropertyValue("--low").trim();
  }

  function bboxStr(arr){ return arr.map(v => Number(v.toFixed(6))).join(","); }

  function getSensors(){
    const out = [];
    if ($("s_snpp").checked) out.push("VIIRS_SNPP_NRT");
    if ($("s_n20").checked) out.push("VIIRS_NOAA20_NRT");
    if ($("s_n21").checked) out.push("VIIRS_NOAA21_NRT");
    if ($("s_modis").checked) out.push("MODIS_NRT");
    return out;
  }

  // ======================
  // MAP INIT
  // ======================
  if (!window.L){
    showMapError(`No se cargó Leaflet (<code>L</code>). Revisa tu conexión o si un bloqueador está deteniendo <code>unpkg.com</code>.`);
    return;
  }

  let map, clusters, overlayGroup;

  const iconCache = new Map();
  function markerIcon(color){
    if (iconCache.has(color)) return iconCache.get(color);
    const icon = L.divIcon({
      className: "",
      html: `<div class="hotspot" style="background:${color}"></div>`,
      iconSize: [14,14],
      iconAnchor: [7,7],
      popupAnchor: [0,-8]
    });
    iconCache.set(color, icon);
    return icon;
  }

  try{
    map = L.map("map", { zoomControl: true }).setView([14.77, -91.18], 10);

    const osm = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors',
    }).addTo(map);

    const imagery = L.tileLayer("https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", {
      maxZoom: 19,
      attribution: "Tiles &copy; Esri",
    });

    L.control.layers({ "OSM": osm, "Satélite (Esri)": imagery }, {}, { position: "topleft" }).addTo(map);

    clusters = (typeof L.markerClusterGroup === "function")
      ? L.markerClusterGroup({ chunkedLoading: true, showCoverageOnHover: false, maxClusterRadius: 55 })
      : L.layerGroup();

    map.addLayer(clusters);
    overlayGroup = L.layerGroup().addTo(map);

    setTimeout(() => map.invalidateSize(), 250);
  }catch(err){
    showMapError(`No se pudo inicializar el mapa: <code>${String(err)}</code>`);
    return;
  }

  function fitToBBox(arr){
    const b = L.latLngBounds([arr[1], arr[0]], [arr[3], arr[2]]);
    map.fitBounds(b.pad(0.06));
  }

  // ======================
  // POLYGONS (capas)
  // ======================
  const polyState = {
    muni:  { loaded:false, gj:null, items:[], nameField:null },
    micro: { loaded:false, gj:null, items:[], nameField:null },
    ap:    { loaded:false, gj:null, items:[], nameField:null },
  };

  function pickNameField(gj){
    if (!gj?.features?.length) return null;
    const preferred = ["NOMBRE","Nombre","nombre","MUNICIPIO","municipio","NOM_MUNI","MICROCUENCA","microcuenca","NOM_AREA","NAME","name"];
    const props = gj.features.map(f => f.properties || {});
    for (const key of preferred){
      let hits = 0;
      for (const p of props){
        const v = p[key];
        if (typeof v === "string" && v.trim()) hits++;
      }
      if (hits >= Math.max(2, Math.floor(props.length * 0.2))) return key;
    }
    const first = props[0] || {};
    for (const [k,v] of Object.entries(first)){
      if (typeof v === "string" && v.trim()) return k;
    }
    return null;
  }

  async function ensurePolyLoaded(mode){
    const st = polyState[mode];
    if (!st || st.loaded) return;

    const src = LAYER_SOURCES[mode];
    setStatus(`Cargando capa: ${src.label}...`);

    const r = await fetch(src.url, { cache: "no-store" });
    if (!r.ok) throw new Error(`No se pudo cargar ${src.url} (HTTP ${r.status})`);
    const gj = await r.json();

    st.gj = gj;
    st.nameField = pickNameField(gj);

    const items = [];
    for (let i = 0; i < (gj.features || []).length; i++){
      const f = gj.features[i];
      const id = f.id ?? (f.properties?.id ?? i);
      const nm = st.nameField ? String(f.properties?.[st.nameField] ?? "").trim() : `Polígono ${i+1}`;
      const bb = turf.bbox(f); // [w,s,e,n]
      items.push({ id: String(id), name: nm || `Polígono ${i+1}`, feature: f, bbox: bb, area_m2: turf.area(f) });
    }
    items.sort((a,b) => a.name.localeCompare(b.name, "es"));
    st.items = items;
    st.loaded = true;

    setStatus(`Capa lista: ${src.label} · ${items.length} polígonos`);
  }

  function populatePolySelect(mode){
    const st = polyState[mode];
    const src = LAYER_SOURCES[mode];

    $("polyLabel").textContent = `Elemento de recorte — ${src.label}`;
    $("polyHint").textContent = `Campo etiqueta: ${st.nameField || "auto"} · Polígonos: ${st.items.length}`;

    const sel = $("polySelect");
    sel.innerHTML = "";

    const optAll = document.createElement("option");
    optAll.value = "all";
    optAll.textContent = `Todos (${st.items.length})`;
    sel.appendChild(optAll);

    for (const it of st.items){
      const opt = document.createElement("option");
      opt.value = it.id;
      opt.textContent = it.name;
      sel.appendChild(opt);
    }
    sel.value = "all";
  }

  function renderPolyOverlay(mode, selectedId){
    overlayGroup.clearLayers();
    const st = polyState[mode];
    if (!st?.loaded) return;

    let features = [];
    if (selectedId === "all"){
      features = st.gj.features;
    } else {
      const it = st.items.find(x => x.id === selectedId);
      if (it) features = [it.feature];
    }
    if (!features.length) return;

    L.geoJSON({ type:"FeatureCollection", features }, {
      style: { color:"#1f9d55", weight:2, opacity:0.85, fillColor:"#fbbf24", fillOpacity:0.08 }
    }).addTo(overlayGroup);
  }

  function getStudyDomain(){
    const mode = $("clipMode").value;
    const st = polyState[mode];
    const sel = $("polySelect").value || "all";

    if (!st?.loaded){
      const fallback = [-91.586608, 14.495833, -91.040503, 14.992742];
      return { bbox: fallback, areaKm2: turf.area(turf.bboxPolygon(fallback))/1e6, label: "Sololá (fallback bbox)", poly: turf.bboxPolygon(fallback) };
    }

    if (sel !== "all"){
      const it = st.items.find(x => x.id === sel);
      if (it){
        return { bbox: it.bbox, areaKm2: it.area_m2/1e6, label: it.name, poly: it.feature };
      }
    }

    const bb = turf.bbox(st.gj);
    return { bbox: bb, areaKm2: turf.area(turf.bboxPolygon(bb))/1e6, label: `${LAYER_SOURCES[mode].label} (bbox)`, poly: turf.bboxPolygon(bb) };
  }

  function pointInSelectedPolygons(rows){
    const mode = $("clipMode").value;
    const st = polyState[mode];
    if (!st?.loaded) return rows;

    const sel = $("polySelect").value || "all";
    const polys = (sel === "all") ? st.items : st.items.filter(x => x.id === sel);
    const zoneType = LAYER_SOURCES[mode].label;

    const out = [];
    for (const r of rows){
      if (!Number.isFinite(r.lat) || !Number.isFinite(r.lon)) continue;
      const pt = turf.point([r.lon, r.lat]);
      let matched = null;

      for (const it of polys){
        if (r.lon < it.bbox[0] || r.lon > it.bbox[2] || r.lat < it.bbox[1] || r.lat > it.bbox[3]) continue;
        if (turf.booleanPointInPolygon(pt, it.feature)){
          matched = it;
          break;
        }
      }
      if (matched){
        out.push({ ...r, zone_type: zoneType, zone_name: matched.name });
      }
    }
    return out;
  }

  // ======================
  // TABLE + MAP DATA
  // ======================
  let dataSpatial = [];
  let dataTableView = [];
  let markerById = new Map();

  function updateMap(rows){
    clusters.clearLayers();
    markerById.clear();
    if (!rows?.length) return;

    for (const r of rows){
      const col = confColor(r.confidence);
      const mk = L.marker([r.lat, r.lon], { icon: markerIcon(col) });

      const zone = r.zone_name ? `<div><b>${r.zone_type}:</b> ${r.zone_name}</div>` : "";
      mk.bindPopup(`
        <div style="font-family:system-ui; font-size:12px; line-height:1.35">
          <div><b>${r.source}</b></div>
          ${zone}
          <div>UTC: ${r.datetime_utc || (r.acq_date + " " + r.acq_time)}</div>
          <div>Conf: ${r.confidence || "—"} · FRP: ${r.frp ?? "—"} MW</div>
          <div>Sat: ${r.satellite || "—"} · Inst: ${r.instrument || "—"}</div>
        </div>
      `);

      markerById.set(r.id, mk);
      clusters.addLayer(mk);
    }
  }

  function buildTable(rows){
    const tbody = $("tbl").querySelector("tbody");
    tbody.innerHTML = "";
    const frag = document.createDocumentFragment();

    for (const r of rows){
      const tr = document.createElement("tr");
      tr.dataset.id = r.id;
      tr.innerHTML = `
        <td>${r.datetime_utc || "—"}</td>
        <td>${r.zone_name || "—"}</td>
        <td>${r.source || "—"}</td>
        <td>${r.confidence || "—"}</td>
        <td>${Number.isFinite(r.lat) ? r.lat.toFixed(5) : "—"}</td>
        <td>${Number.isFinite(r.lon) ? r.lon.toFixed(5) : "—"}</td>
        <td>${r.frp ?? "—"}</td>
      `;
      frag.appendChild(tr);
    }
    tbody.appendChild(frag);

    tbody.querySelectorAll("tr").forEach(tr => {
      tr.addEventListener("click", () => {
        const mk = markerById.get(tr.dataset.id);
        if (!mk) return;
        map.setView(mk.getLatLng(), Math.max(map.getZoom(), 13));
        mk.openPopup();
      });
    });
  }

  function applyTableFilter(){
    const q = $("q").value.trim().toLowerCase();
    if (!q){
      dataTableView = dataSpatial.slice();
    } else {
      dataTableView = dataSpatial.filter(r => JSON.stringify(r).toLowerCase().includes(q));
    }
    buildTable(dataTableView);
    $("tableNote").textContent = `Mostrando ${dataTableView.length} / ${dataSpatial.length} filas (filtro de tabla).`;
  }

  function updateKPIs(rows, payload){
    const total = rows.length;
    const hi = rows.reduce((acc, r) => acc + (confClass(r.confidence) === "high" ? 1 : 0), 0);
    const frpSum = rows.reduce((acc, r) => acc + (Number.isFinite(r.frp) ? r.frp : 0), 0);

    $("k_total").textContent = fmt(total);
    $("k_high").textContent = fmt(hi);
    $("k_frp").textContent = fmt(frpSum, 3);
    $("k_last").textContent = payload?.summary?.last_detection_utc || "—";
  }

  // ======================
  // EXPORTS
  // ======================
  function exportExcel(){
    const rows = dataTableView.length ? dataTableView : dataSpatial;
    if (!rows.length) return;

    if (!window.XLSX){
      setStatus("No se cargó XLSX (SheetJS). Usa CSV por ahora.");
      return;
    }
    const out = rows.map(r => ({
      datetime_utc: r.datetime_utc || "",
      zone_type: r.zone_type || "",
      zone_name: r.zone_name || "",
      source: r.source || "",
      confidence: r.confidence || "",
      lat: r.lat,
      lon: r.lon,
      frp: r.frp,
      satellite: r.satellite || "",
      instrument: r.instrument || "",
      acq_date: r.acq_date || "",
      acq_time: r.acq_time || "",
    }));
    const ws = XLSX.utils.json_to_sheet(out);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, "Hotspots");
    XLSX.writeFile(wb, "firs_hotspots_tabla.xlsx");
  }

  function exportCSV(){
    const rows = dataTableView.length ? dataTableView : dataSpatial;
    if (!rows.length) return;

    const cols = ["datetime_utc","zone_type","zone_name","source","confidence","lat","lon","frp","satellite","instrument","acq_date","acq_time"];
    const lines = [cols.join(",")];
    for (const r of rows){
      const row = cols.map(c => {
        const v = (r[c] ?? "").toString();
        if (v.includes(",") || v.includes('"') || v.includes("\n")) return `"${v.replaceAll('"','""')}"`;
        return v;
      });
      lines.push(row.join(","));
    }
    const blob = new Blob([lines.join("\n")], { type:"text/csv;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "firs_hotspots_tabla.csv";
    document.body.appendChild(a);
    a.click(); a.remove();
    URL.revokeObjectURL(a.href);
  }

  function exportGeoJSON(){
    const rows = dataSpatial;
    if (!rows.length) return;

    const fc = {
      type: "FeatureCollection",
      features: rows.map(r => ({
        type: "Feature",
        geometry: { type: "Point", coordinates: [r.lon, r.lat] },
        properties: { ...r }
      }))
    };
    const blob = new Blob([JSON.stringify(fc, null, 2)], { type:"application/geo+json;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "firs_hotspots_puntos.geojson";
    document.body.appendChild(a);
    a.click(); a.remove();
    URL.revokeObjectURL(a.href);
  }

  // ======================
  // GEOESTATS + CHARTS
  // ======================
  let chartDaily = null;
  let chartSensors = null;
  let chartZonesPie = null;
  let chartRipley = null;
  let chartVariogram = null;
  let chartNN = null;

  function normalCdf(z){
    // Abramowitz-Stegun approximation
    const sign = z < 0 ? -1 : 1;
    z = Math.abs(z) / Math.sqrt(2);
    const t = 1 / (1 + 0.3275911 * z);
    const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429;
    const erf = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-z*z);
    return 0.5 * (1 + sign * erf);
  }

  function linearRegression(xs, ys){
    const n = xs.length;
    if (n < 2) return { a: 0, b: ys[0] ?? 0, r2: 0 };
    const meanX = xs.reduce((s,v)=>s+v,0)/n;
    const meanY = ys.reduce((s,v)=>s+v,0)/n;
    let num = 0, den = 0;
    for (let i=0;i<n;i++){
      num += (xs[i]-meanX)*(ys[i]-meanY);
      den += (xs[i]-meanX)*(xs[i]-meanX);
    }
    const a = den === 0 ? 0 : num/den;
    const b = meanY - a*meanX;
    let ssTot = 0, ssRes = 0;
    for (let i=0;i<n;i++){
      const yHat = a*xs[i] + b;
      ssTot += (ys[i]-meanY)**2;
      ssRes += (ys[i]-yHat)**2;
    }
    const r2 = ssTot === 0 ? 0 : 1 - (ssRes/ssTot);
    return { a, b, r2 };
  }

  function buildDailySeries(rows){
    const byDate = new Map();
    const byDateFrp = new Map();
    for (const r of rows){
      const d = r.acq_date || (r.datetime_utc ? r.datetime_utc.slice(0,10) : null);
      if (!d) continue;
      byDate.set(d, (byDate.get(d) || 0) + 1);
      byDateFrp.set(d, (byDateFrp.get(d) || 0) + (Number.isFinite(r.frp) ? r.frp : 0));
    }
    const dates = Array.from(byDate.keys()).sort();
    const counts = dates.map(d => byDate.get(d) || 0);
    const frps = dates.map(d => +(byDateFrp.get(d) || 0).toFixed(3));
    return { dates, counts, frps };
  }

  function sampleRows(rows, maxN){
    if (rows.length <= maxN) return rows;
    const copy = rows.slice();
    for (let i = copy.length - 1; i > 0; i--){
      const j = Math.floor(Math.random() * (i + 1));
      [copy[i], copy[j]] = [copy[j], copy[i]];
    }
    return copy.slice(0, maxN);
  }

  function kmDistance(a, b){
    return turf.distance(turf.point([a.lon, a.lat]), turf.point([b.lon, b.lat]), { units: "kilometers" });
  }

  function computeNearestNeighborStats(points, areaKm2){
    const n = points.length;
    if (n < 2 || !areaKm2 || areaKm2 <= 0) return null;

    const nn = [];
    for (let i=0;i<n;i++){
      let best = Infinity;
      for (let j=0;j<n;j++){
        if (i===j) continue;
        const d = kmDistance(points[i], points[j]);
        if (d < best) best = d;
      }
      if (Number.isFinite(best)) nn.push(best);
    }

    const rObs = nn.reduce((a,b)=>a+b,0)/nn.length;
    const lam = n / areaKm2;
    const rExp = 0.5 / Math.sqrt(lam);

    const se = 0.26136 / Math.sqrt(n * lam);
    const z = se > 0 ? (rObs - rExp) / se : null;
    const p = (z == null) ? null : 2 * (1 - normalCdf(Math.abs(z)));

    return { n, lam, rObs, rExp, nni: rObs/rExp, z, p, nn };
  }

  function computeRipleyL(points, areaKm2, rMaxKm=20, bins=25){
    const n = points.length;
    if (n < 2 || !areaKm2 || areaKm2 <= 0) return null;

    const dr = rMaxKm / bins;
    const hist = new Array(bins).fill(0);

    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        const d = kmDistance(points[i], points[j]);
        if (d <= rMaxKm){
          const k = Math.min(bins-1, Math.floor(d / dr));
          hist[k] += 1;
        }
      }
    }

    const cum = [];
    let s = 0;
    for (let k=0;k<bins;k++){ s += hist[k]; cum.push(s); }

    const rs = [];
    const L = [];
    for (let k=0;k<bins;k++){
      const r = (k+1) * dr;
      rs.push(r);
      const pairLE = cum[k];
      const K = (areaKm2 / (n*(n-1))) * (2 * pairLE);
      L.push(Math.sqrt(K / Math.PI) - r);
    }
    return { rs, L };
  }

  function randomPointsInPolygon(n, poly, bbox){
    const pts = [];
    let attempts = 0;
    const maxAttempts = n * 120;
    while (pts.length < n && attempts < maxAttempts){
      const x = bbox[0] + Math.random() * (bbox[2]-bbox[0]);
      const y = bbox[1] + Math.random() * (bbox[3]-bbox[1]);
      const p = turf.point([x,y]);
      if (turf.booleanPointInPolygon(p, poly)) pts.push({ lon:x, lat:y });
      attempts++;
    }
    return pts;
  }

  async function ripleyMonteCarlo(obsPts, domain, rMaxKm=20, bins=25){
    const n = obsPts.length;
    if (n < 10) return null;

    let sims = 99;
    if (n > 200) sims = 39;
    if (n > 350) sims = 19;

    const obs = computeRipleyL(obsPts, domain.areaKm2, rMaxKm, bins);
    if (!obs) return null;

    const upper = new Array(obs.L.length).fill(-Infinity);
    const lower = new Array(obs.L.length).fill(Infinity);

    const obsMax = Math.max(...obs.L);
    const obsMin = Math.min(...obs.L);

    let geMax = 0, leMin = 0;

    for (let s=0; s<sims; s++){
      const simPts = randomPointsInPolygon(n, domain.poly, domain.bbox);
      if (simPts.length < n) continue;

      const sim = computeRipleyL(simPts, domain.areaKm2, rMaxKm, bins);
      if (!sim) continue;

      for (let i=0;i<sim.L.length;i++){
        upper[i] = Math.max(upper[i], sim.L[i]);
        lower[i] = Math.min(lower[i], sim.L[i]);
      }

      const mx = Math.max(...sim.L);
      const mn = Math.min(...sim.L);
      if (mx >= obsMax) geMax++;
      if (mn <= obsMin) leMin++;
    }

    const pCluster = (geMax + 1) / (sims + 1);
    const pRegular = (leMin + 1) / (sims + 1);
    return { sims, obs, upper, lower, pCluster, pRegular };
  }

  function computeSDE(points){
    const n = points.length;
    if (n < 2) return null;
    const lat0 = points.reduce((a,p)=>a+p.lat,0)/n;
    const lon0 = points.reduce((a,p)=>a+p.lon,0)/n;

    const kx = 111.32 * Math.cos(lat0 * Math.PI/180);
    const ky = 110.574;

    const xs = points.map(p => (p.lon - lon0) * kx);
    const ys = points.map(p => (p.lat - lat0) * ky);

    let sdx2=0, sdy2=0, sxy=0;
    for (let i=0;i<n;i++){
      sdx2 += xs[i]*xs[i];
      sdy2 += ys[i]*ys[i];
      sxy  += xs[i]*ys[i];
    }
    const varx = sdx2/n, vary=sdy2/n, cov=sxy/n;
    const tr = varx + vary;
    const det = varx*vary - cov*cov;
    const disc = Math.max(0, tr*tr - 4*det);
    const l1 = (tr + Math.sqrt(disc))/2;
    const l2 = (tr - Math.sqrt(disc))/2;

    const major = Math.sqrt(Math.max(0,l1));
    const minor = Math.sqrt(Math.max(0,l2));
    const angle = 0.5 * Math.atan2(2*cov, (varx - vary));
    const az = (angle * 180/Math.PI + 360) % 180;

    const sd = Math.sqrt(varx + vary);
    return { sd, major, minor, az };
  }

  function computeVariogram(points, rMaxKm=20, bins=20){
    const usable = points.filter(p => Number.isFinite(p.frp));
    const n = usable.length;
    if (n < 6) return null;

    const dr = rMaxKm / bins;
    const count = new Array(bins).fill(0);
    const sumSq = new Array(bins).fill(0);

    for (let i=0;i<n;i++){
      for (let j=i+1;j<n;j++){
        const d = kmDistance(usable[i], usable[j]);
        if (d <= rMaxKm){
          const k = Math.min(bins-1, Math.floor(d / dr));
          const diff = usable[i].frp - usable[j].frp;
          sumSq[k] += diff*diff;
          count[k] += 1;
        }
      }
    }

    const hs=[], gamma=[];
    for (let k=0;k<bins;k++){
      hs.push(+(((k+0.5)*dr).toFixed(3)));
      gamma.push(count[k] ? (0.5*(sumSq[k]/count[k])) : null);
    }
    return { hs, gamma };
  }

  function setChartColors(ds, border, fill){
    ds.borderColor = border;
    ds.backgroundColor = fill;
    ds.pointBackgroundColor = border;
    return ds;
  }

  function updateGeoKPIs(geo){
    $("g_area").textContent = geo.areaKm2 != null ? `${geo.areaKm2.toFixed(2)} km²` : "—";
    $("g_area_s").textContent = geo.areaLabel || "—";
    $("g_n").textContent = `${geo.nSample} / ${geo.nTotal}`;
    $("g_n_s").textContent = geo.sampleNote || "";
    $("g_lambda").textContent = geo.lam != null ? geo.lam.toFixed(4) : "—";
    $("g_nni").textContent = geo.nni != null ? geo.nni.toFixed(3) : "—";
    $("g_nni_s").textContent = geo.nniText || "—";
    $("g_z").textContent = geo.z != null ? geo.z.toFixed(2) : "—";
    $("g_p").textContent = geo.p != null ? `p: ${geo.p.toExponential(2)}` : "p: —";
    $("g_lmax").textContent = geo.lmax != null ? `${geo.lmax.toFixed(3)} km` : "—";
    $("g_lr").textContent = geo.lAt != null ? `r*: ${geo.lAt.toFixed(2)} km` : "r*: —";
    $("g_mc").textContent = geo.mcLabel || "CSR: —";
    $("g_mc_s").textContent = geo.mcP || "—";
    $("g_sd").textContent = geo.sd != null ? `${geo.sd.toFixed(2)} km` : "—";
    $("g_sde").textContent = geo.sdeText || "—";
  }

  function buildInterpretation(geo){
    // Reglas de interpretación (cortas, técnicas)
    const lines = [];
    lines.push(`• Dominio de estudio: ${geo.areaLabel}. Intensidad λ mide densidad de detecciones (puntos/km²) en el recorte.`);
    if (geo.nni != null){
      if (geo.nni < 1){
        lines.push(`• NNI < 1 sugiere *agrupamiento* (clusters) de focos de calor; si p < 0.05, el agrupamiento es estadísticamente significativo vs CSR.`);
      } else if (geo.nni > 1){
        lines.push(`• NNI > 1 sugiere patrón más *regular/inhibido* (separación entre focos); si p < 0.05, la regularidad es significativa vs CSR.`);
      } else {
        lines.push(`• NNI ≈ 1 sugiere patrón compatible con Aleatoriedad Completa Espacial (CSR) a escala de vecino más cercano.`);
      }
    }
    if (geo.mcLabel){
      lines.push(`• Ripley L(r) + envelope CSR evalúa *multiescala*: clustering si L(r) excede el envelope; inhibición si cae por debajo. Reporte: ${geo.mcLabel}.`);
    }
    if (geo.lAt != null){
      lines.push(`• Escala característica (r*): ${geo.lAt.toFixed(2)} km donde L(r) alcanza su pico (máxima evidencia de agrupamiento a esa distancia).`);
    }
    if (geo.sdeText){
      lines.push(`• SDE resume dispersión espacial global y orientación (anisotropía). Útil para ver “hacia dónde” se extiende la nube de focos.`);
    }
    lines.push(`• Implicación operativa: clusters persistentes pueden indicar frentes activos o quemas repetidas; combinar con viento, uso/cobertura y verificación local.`);
    return lines.join("\n");
  }

  function updateChartsAndGeo(rows, domain){
    const css = getComputedStyle(document.documentElement);
    const GREEN = css.getPropertyValue("--green").trim() || "#1f9d55";
    const AMBER = css.getPropertyValue("--amber").trim() || "#fbbf24";
    const GOLD  = css.getPropertyValue("--gold").trim() || "#f59e0b";
    const LIME  = css.getPropertyValue("--lime").trim() || "#a3e635";

    // Serie temporal + OLS
    const { dates, counts, frps } = buildDailySeries(rows);
    const xs = dates.map((_,i)=>i);
    const reg = linearRegression(xs, counts);
    const trend = xs.map(x => reg.a*x + reg.b);

    $("eqDaily").innerHTML = `\\(y=${reg.a.toFixed(3)}x+${reg.b.toFixed(3)},\\;R^2=${Math.max(0,Math.min(1,reg.r2)).toFixed(3)}\\)`;

    const ctx1 = $("chartDaily").getContext("2d");
    if (chartDaily) chartDaily.destroy();
    chartDaily = new Chart(ctx1, {
      type: "line",
      data: {
        labels: dates,
        datasets: [
          setChartColors({ label: "Detecciones/día", data: counts, tension: 0.25 }, GREEN, "rgba(31,157,85,.12)"),
          { label: "Tendencia (OLS)", data: trend, tension: 0, borderDash: [6,6], pointRadius: 0, borderColor: GOLD },
          setChartColors({ label: "FRP/día (MW)", data: frps, yAxisID: "y2", tension: 0.25 }, AMBER, "rgba(245,158,11,.12)")
        ]
      },
      options: {
        responsive: true,
        plugins: { legend: { position: "bottom" } },
        scales: {
          y: { beginAtZero: true, title: { display: true, text: "Detecciones" } },
          y2: { beginAtZero: true, position: "right", grid: { drawOnChartArea: false }, title: { display: true, text: "FRP (MW)" } }
        }
      }
    });

    // Sensor chart
    const bySensor = {};
    for (const r of rows){ bySensor[r.source || "—"] = (bySensor[r.source || "—"] || 0) + 1; }
    const sensors = Object.keys(bySensor).sort();
    const vals = sensors.map(s => bySensor[s]);

    const ctx2 = $("chartSensors").getContext("2d");
    if (chartSensors) chartSensors.destroy();
    chartSensors = new Chart(ctx2, {
      type: "bar",
      data: { labels: sensors, datasets: [{ label:"Detecciones", data: vals, backgroundColor: "rgba(163,230,53,.45)", borderColor: LIME, borderWidth: 1.5 }] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true } } }
    });


    // Zona chart (dependiente de capa): conteo por zone_name
    const mode = $("clipMode").value;
    const layerLabel = (LAYER_SOURCES[mode] && LAYER_SOURCES[mode].label) ? LAYER_SOURCES[mode].label : "zona";
    const byZone = {};
    for (const r of rows){
      const z = (r.zone_name && String(r.zone_name).trim()) ? String(r.zone_name).trim() : "Sin zona";
      byZone[z] = (byZone[z] || 0) + 1;
    }

    const entries = Object.entries(byZone).sort((a,b)=>b[1]-a[1]);
    const TOPK = 12;
    const top = entries.slice(0, TOPK);
    const rest = entries.slice(TOPK);
    if (rest.length){
      const s = rest.reduce((acc, x)=>acc+x[1], 0);
      top.push(["Otros", s]);
    }

    const zoneLabels = top.map(x=>x[0]);
    const zoneVals = top.map(x=>x[1]);

    const zTitle = $("zoneChartTitle");
    const zNote  = $("zoneChartNote");
    if (zTitle) zTitle.textContent = `Detecciones por ${layerLabel}`;
    if (zNote) zNote.innerHTML = `Conteo de detecciones (no eventos únicos). Capa activa: <b>${layerLabel}</b>.`;

    const ctxZ = $("chartZonesPie")?.getContext?.("2d");
    if (ctxZ){
      if (chartZonesPie) chartZonesPie.destroy();

      // Colores gradiente verde→amarillo (HSL)
      const nC = Math.max(1, zoneLabels.length);
      const bg = [];
      const bd = [];
      for (let i=0; i<nC; i++){
        const t = (nC === 1) ? 0 : (i/(nC-1));
        const hue = 120 - t*70; // 120 verde -> 50 amarillo
        bg.push(`hsla(${hue}, 80%, 45%, 0.72)`);
        bd.push(`hsla(${hue}, 80%, 35%, 1)`);
      }

      chartZonesPie = new Chart(ctxZ, {
        type: "pie",
        data: {
          labels: zoneLabels,
          datasets: [{
            label: `Detecciones por ${layerLabel}`,
            data: zoneVals,
            backgroundColor: bg,
            borderColor: bd,
            borderWidth: 1.2
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { position: "bottom" },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const v = ctx.parsed;
                  const total = zoneVals.reduce((a,b)=>a+b,0) || 1;
                  const p = (100*v/total);
                  return ` ${ctx.label}: ${v} (${p.toFixed(1)}%)`;
                }
              }
            }
          }
        }
      });
    }

    // Geo sampling
    const MAX_GEO_N = 350;
    const ptsAll = rows.map(r => ({ lat:r.lat, lon:r.lon, frp: (Number.isFinite(r.frp)?r.frp:null) }))
                      .filter(p => Number.isFinite(p.lat) && Number.isFinite(p.lon));
    const pts = sampleRows(ptsAll, MAX_GEO_N);

    const geo = {
      areaKm2: domain.areaKm2,
      areaLabel: domain.label,
      nSample: pts.length,
      nTotal: ptsAll.length,
      sampleNote: ptsAll.length > pts.length ? `muestra aleatoria (cap=${MAX_GEO_N})` : "sin muestreo",
      lam: (domain.areaKm2 && pts.length) ? (pts.length/domain.areaKm2) : null,
      nni: null, z: null, p: null, nniText: "—",
      lmax: null, lAt: null,
      mcLabel: "CSR: calculando…",
      mcP: "—",
      sd: null, sdeText: "—"
    };

    if (!domain.areaKm2 || pts.length < 10){
      updateGeoKPIs(geo);
      $("eqRipley").innerHTML = "Se requieren ≥10 puntos y área válida.";
      $("eqVario").innerHTML = "Se requieren suficientes puntos con FRP.";
      $("geoInterpret").textContent = "Interpretación: no hay suficientes datos para geoestadística en este recorte.";
      return;
    }

    // NNI
    const nni = computeNearestNeighborStats(pts, domain.areaKm2);
    if (nni){
      geo.nni = nni.nni;
      geo.z = nni.z;
      geo.p = nni.p;
      const pattern = (nni.nni < 1) ? "cluster" : (nni.nni > 1 ? "regular" : "CSR~1");
      geo.nniText = `\\(\\bar r_{obs}=${nni.rObs.toFixed(3)}\\,km,\\;\\bar r_{exp}=${nni.rExp.toFixed(3)}\\,km\\) · ${pattern}`;
    }

    // SDE
    const sde = computeSDE(pts);
    if (sde){
      geo.sd = sde.sd;
      geo.sdeText = `\\(a=${sde.major.toFixed(2)}\\,km,\\;b=${sde.minor.toFixed(2)}\\,km,\\;az=${sde.az.toFixed(1)}^\\circ\\)`;
    }

    // Ripley observed
    const rip = computeRipleyL(pts, domain.areaKm2, 20, 25);
    if (rip){
      let imax = 0;
      for (let i=1;i<rip.L.length;i++){
        if (rip.L[i] > rip.L[imax]) imax = i;
      }
      geo.lmax = rip.L[imax];
      geo.lAt = rip.rs[imax];
    }

    updateGeoKPIs(geo);

    // NN hist
    if (nni && nni.nn?.length){
      const nnSorted = nni.nn.slice().sort((a,b)=>a-b);
      const maxD = Math.min(10, nnSorted[Math.floor(nnSorted.length*0.98)] || 10);
      const bins = 20;
      const step = maxD / bins;
      const h = new Array(bins).fill(0);
      for (const d of nnSorted){
        if (d > maxD) continue;
        const k = Math.min(bins-1, Math.floor(d/step));
        h[k] += 1;
      }
      const xh = h.map((_,k)=>+( (k+0.5)*step ).toFixed(3));
      const ctxNN = $("chartNN").getContext("2d");
      if (chartNN) chartNN.destroy();
      chartNN = new Chart(ctxNN, {
        type: "bar",
        data: { labels: xh.map(v=>String(v)), datasets: [{ label: "Vecino más cercano (km)", data: h, backgroundColor:"rgba(31,157,85,.25)", borderColor: GREEN, borderWidth: 1.2 }] },
        options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ beginAtZero:true }, x:{ title:{ display:true, text:"km" } } } }
      });
    }

    // Variogram
    const vario = computeVariogram(pts, 20, 20);
    $("eqVario").innerHTML = `\\(\\gamma(h)=\\tfrac{1}{2}\\,E[(z(s)-z(s+h))^2]\\) (\\(z=\\) FRP).`;
    const ctxV = $("chartVariogram").getContext("2d");
    if (chartVariogram) chartVariogram.destroy();
    chartVariogram = new Chart(ctxV, {
      type: "line",
      data: { labels: vario ? vario.hs.map(v=>String(v)) : [],
              datasets: vario ? [ setChartColors({ label: "γ(h) — FRP", data: vario.gamma.map(v => v==null?null:+v.toFixed(4)), tension: 0.1 }, GOLD, "rgba(245,158,11,.14)") ] : [] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ title:{ display:true, text:"γ(h)" } }, x:{ title:{ display:true, text:"h (km)" } } } }
    });

    // Ripley with envelope
    (async () => {
      $("eqRipley").innerHTML = `\\(L(r)=\\sqrt{K(r)/\\pi}-r\\) con envelope CSR (Monte Carlo).`;

      const ctxR = $("chartRipley").getContext("2d");
      if (chartRipley) chartRipley.destroy();

      const mc = await ripleyMonteCarlo(pts, domain, 20, 25);
      if (!mc){
        chartRipley = new Chart(ctxR, {
          type: "line",
          data: { labels: rip ? rip.rs.map(r=>String(r.toFixed(3))) : [],
                  datasets: rip ? [ setChartColors({ label: "L(r) observado", data: rip.L.map(v=>+v.toFixed(4)), tension:0.1 }, GREEN, "rgba(31,157,85,.12)") ] : [] },
          options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ title:{ display:true, text:"L(r) (km)" } }, x:{ title:{ display:true, text:"r (km)" } } } }
        });
        geo.mcLabel = "CSR: sin envelope";
        updateGeoKPIs(geo);
        $("geoInterpret").textContent = buildInterpretation(geo);
        renderMath();
        return;
      }

      let label = "CSR: no concluyente";
      if (mc.pCluster < 0.05) label = "CSR: cluster (p<0.05)";
      else if (mc.pRegular < 0.05) label = "CSR: regular (p<0.05)";

      geo.mcLabel = label;
      geo.mcP = `p(cluster): ${mc.pCluster.toExponential(2)} · p(regular): ${mc.pRegular.toExponential(2)} · sims=${mc.sims}`;
      updateGeoKPIs(geo);

      chartRipley = new Chart(ctxR, {
        type: "line",
        data: {
          labels: mc.obs.rs.map(r=>String(r.toFixed(3))),
          datasets: [
            setChartColors({ label: "L(r) observado", data: mc.obs.L.map(v=>+v.toFixed(4)), tension: 0.1 }, GREEN, "rgba(31,157,85,.12)"),
            { label: "Envelope superior (CSR)", data: mc.upper.map(v=>+v.toFixed(4)), tension: 0.1, pointRadius: 0, borderDash: [6,6], borderColor: AMBER },
            { label: "Envelope inferior (CSR)", data: mc.lower.map(v=>+v.toFixed(4)), tension: 0.1, pointRadius: 0, borderDash: [6,6], borderColor: AMBER },
          ]
        },
        options: { responsive:true, plugins:{ legend:{ position:"bottom" } }, scales:{ y:{ title:{ display:true, text:"L(r) (km)" } }, x:{ title:{ display:true, text:"r (km)" } } } }
      });

      $("geoInterpret").textContent = buildInterpretation(geo);
      renderMath();
    })();

    // quick interpretation even before MC finishes
    $("geoInterpret").textContent = buildInterpretation(geo);
  }

  // ======================
  // KaTeX render
  // ======================
  function renderMath(){
    if (window.renderMathInElement){
      renderMathInElement(document.body, {
        delimiters: [
          { left: "$$", right: "$$", display: true },
          { left: "\\[", right: "\\]", display: true },
          { left: "\\(", right: "\\)", display: false },
        ],
        throwOnError: false
      });
    }
  }

  // ======================
  // HEALTH + AUTO
  // ======================
  let autoTimer = null;

  async function checkHealth(){
    const dot = $("dot");
    try{
      const r = await fetch(`${PROXY_BASE}/health`);
      const j = await r.json();
      $("pillText").textContent = j.ok ? "Proxy: OK" : "Proxy: error";
      if (dot) dot.style.background = j.ok ? "#2fd08f" : "#f0b24d";
    }catch(e){
      $("pillText").textContent = "Proxy: no responde";
      if (dot) dot.style.background = "#f0b24d";
    }
  }

  function setupAuto(){
    if (autoTimer) clearInterval(autoTimer);
    if ($("auto").checked) autoTimer = setInterval(run, 10 * 60 * 1000);
  }

  // ======================
  // RUN
  // ======================
  async function run(){
    const days = Number($("days").value);
    const sensors = getSensors();
    const limit = Number($("limit").value);
    const conf = $("conf").value;

    if (!sensors.length) return setStatus("Selecciona al menos un sensor.");

    const domain = getStudyDomain();
    const bbox = bboxStr(domain.bbox);

    const url = `${PROXY_BASE}/api/firms?bbox=${encodeURIComponent(bbox)}&days=${days}&sensors=${encodeURIComponent(sensors.join(","))}&limit=${limit}`;
    setStatus(`Consultando FIRMS...\n${url}`);

    const t0 = performance.now();
    const r = await fetch(url);
    const j = await r.json();
    const ms = Math.round(performance.now() - t0);

    if (!r.ok && !j.ok){
      const extra = (j?.error && String(j.error).includes("1..30"))
        ? "\n\nNota: para 60/90 días, sube MAX_DAYS a 90 en el Worker y redeploy."
        : "";
      return setStatus(`Error (${r.status}).\n${j.error || "Sin detalle"}${extra}`);
    }

    let rows = (j.rows || []).filter(rr => conf === "all" ? true : confClass(rr.confidence) === conf);
    rows = pointInSelectedPolygons(rows);
    rows.sort((a,b) => (a.datetime_utc || "") < (b.datetime_utc || "") ? 1 : -1);

    dataSpatial = rows;
    dataTableView = rows.slice();

    setStatus(`OK. Detecciones: ${rows.length} (ya recortadas). Respuesta FIRMS: ${j.rows.length} filas. (${ms} ms)`);
    $("lastRun").textContent = `Última actualización: ${new Date().toLocaleString("es-GT")}`;

    updateMap(dataSpatial);
    applyTableFilter();
    updateKPIs(dataSpatial, j);

    updateChartsAndGeo(dataSpatial, domain);

    renderPolyOverlay($("clipMode").value, $("polySelect").value || "all");
    fitToBBox(domain.bbox);

    $("mapSubtitle").textContent = `${LAYER_SOURCES[$("clipMode").value].label} · ${domain.label}`;
    setTimeout(() => map.invalidateSize(), 120);

    renderMath();
  }

  // ======================
  // UI update
  // ======================
  async function updateClipUI(){
    const mode = $("clipMode").value;
    await ensurePolyLoaded(mode);
    populatePolySelect(mode);
    renderPolyOverlay(mode, $("polySelect").value || "all");
    const domain = getStudyDomain();
    $("mapSubtitle").textContent = `${LAYER_SOURCES[mode].label} · ${domain.label}`;
    fitToBBox(domain.bbox);
    renderMath();
  }

  // ======================
  // EVENTS
  // ======================
  $("btnRun").addEventListener("click", run);
  $("btnFit").addEventListener("click", () => {
    const domain = getStudyDomain();
    fitToBBox(domain.bbox);
    setStatus("Mapa ajustado al recorte.");
  });

  $("btnExcel").addEventListener("click", exportExcel);
  $("btnCSV").addEventListener("click", exportCSV);
  $("btnGeoJSON").addEventListener("click", exportGeoJSON);

  $("q").addEventListener("input", applyTableFilter);
  $("btnClear").addEventListener("click", () => { $("q").value=""; applyTableFilter(); });

  $("clipMode").addEventListener("change", async () => {
    await updateClipUI();
    await run();
  });

  $("polySelect").addEventListener("change", async () => {
    await run();
  });

  $("auto").addEventListener("change", setupAuto);

  // INIT
  (async function init(){
    await checkHealth();
    setupAuto();

    // wait for KaTeX scripts to load (defer)
    const waitKatex = async () => {
      for (let i=0; i<30; i++){
        if (window.renderMathInElement) return;
        await new Promise(res => setTimeout(res, 150));
      }
    };
    await waitKatex();

    await updateClipUI();
    await run();
    renderMath();
  })();
})();
</script>
</body>
</html>
